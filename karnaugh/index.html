<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Map Visual amb Colors</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --cell-size: 70px; /* Cel·les més grans per veure bé els marcadors */
        }

        body { font-family: 'Segoe UI', sans-serif; background-color: #f8f9fa; }
        
        .kmap-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        /* Estils SVG */
        text { font-family: sans-serif; font-weight: bold; pointer-events: none; }
        
        .cell-rect { 
            stroke: #dee2e6; 
            stroke-width: 2; 
            fill: white;
            cursor: pointer; 
            transition: fill 0.2s; 
        }
        .cell-rect:hover { fill: #e9ecef; }
        
        /* Textos 0, 1, X */
        .cell-value { font-size: 24px; transition: opacity 0.2s; }

        /* Targetes */
        .explanation-card {
            border-left: 8px solid #ccc;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .explanation-card:hover {
            transform: translateX(10px);
            background-color: #fff;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        /* El puntet de color dins la targeta */
        .color-dot {
            height: 15px; width: 15px; 
            border-radius: 50%; 
            display: inline-block; 
            margin-right: 8px;
        }

    </style>
</head>
<body>

<div class="container py-5">
    <h2 class="text-center mb-4"><i class="fas fa-project-diagram"></i> Solucionador K-Map Visual</h2>

    <div class="row g-4">
        <div class="col-lg-6">
            <div class="card shadow border-0 h-100">
                <div class="card-header bg-dark text-white d-flex justify-content-between align-items-center">
                    <span class="fw-bold">Mapa Interactiu</span>
                    <small>Clic: 0 → 1 → X</small>
                </div>
                <div class="card-body text-center d-flex flex-column justify-content-center">
                    <div class="kmap-wrapper">
                        <div id="kmap-container"></div>
                    </div>
                    
                    <div class="mt-3">
                        <button class="btn btn-danger btn-sm px-4 rounded-pill" onclick="resetCells()"><i class="fas fa-trash"></i> Netejar</button>
                        <button class="btn btn-outline-dark btn-sm px-4 rounded-pill" onclick="randomize()"><i class="fas fa-random"></i> Aleatori</button>
                    </div>
                </div>
                <div class="card-footer bg-light">
                    <div class="d-flex align-items-center justify-content-center">
                        <span class="me-3 text-muted text-uppercase small fw-bold">Resultat:</span>
                        <div id="simplified-expr" class="fs-3 fw-bold font-monospace text-primary">0</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-lg-6">
            <div class="card shadow border-0 h-100">
                <div class="card-header bg-primary text-white">
                    <h5 class="m-0"><i class="fas fa-list-ol me-2"></i>Pas a Pas (Colors)</h5>
                </div>
                <div class="card-body bg-light" id="step-by-step" style="max-height: 600px; overflow-y: auto;">
                    <div class="text-center text-muted py-5">
                        <i class="fas fa-mouse-pointer fa-2x mb-3"></i>
                        <p>Marca uns (1) al mapa per veure com s'agrupen.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    const variables = ['A', 'B', 'C', 'D'];
    let cells = Array(16).fill(0);
    
    // Ordre Gray per dibuixar
    const rowGray = [0, 1, 3, 2];
    const colGray = [0, 1, 3, 2];
    
    // Paleta de colors vibrants per als grups
    const palette = [
        { color: '#FF0055', bg: 'rgba(255, 0, 85, 0.1)' },   // Vermell/Rosa
        { color: '#0099FF', bg: 'rgba(0, 153, 255, 0.1)' },  // Blau
        { color: '#00CC66', bg: 'rgba(0, 204, 102, 0.1)' },  // Verd
        { color: '#FFAA00', bg: 'rgba(255, 170, 0, 0.1)' },  // Taronja
        { color: '#9933FF', bg: 'rgba(153, 51, 255, 0.1)' }, // Lila
        { color: '#333333', bg: 'rgba(50, 50, 50, 0.1)' }    // Negre (extra)
    ];

    // --- Lògica Quine-McCluskey (Simplificada) ---
    function toBinary(n) { return n.toString(2).padStart(4, '0'); }
    function countOnes(str) { return str.split('').filter(bit => bit === '1').length; }
    function combineTerms(term1, term2) {
        let diffCount = 0;
        let combined = '';
        for (let i = 0; i < term1.length; i++) {
            if (term1[i] === term2[i]) combined += term1[i];
            else { diffCount++; combined += '-'; }
        }
        return diffCount === 1 ? combined : null;
    }
    function covers(term, minterm) {
        const bin = toBinary(minterm);
        for (let i = 0; i < term.length; i++) {
            if (term[i] !== '-' && term[i] !== bin[i]) return false;
        }
        return true;
    }

    function solveKMap(ones, dontCares) {
        if (ones.length === 0) return [];
        // Cas especial: Tot ple
        if (ones.length + dontCares.length === 16) {
            return [{ term: '----', minterms: Array.from({length:16}, (_,i)=>i) }];
        }

        // 1. Generar Implicants Primers
        let terms = ones.concat(dontCares).map(m => ({ term: toBinary(m), minterms: [m], used: false }));
        let primes = [];
        
        // Cicles de combinació (bàsic)
        for(let cycle=0; cycle<4; cycle++){
            let nextTerms = [];
            let groups = {};
            terms.forEach(t => {
                let c = countOnes(t.term);
                if(!groups[c]) groups[c]=[];
                groups[c].push(t);
            });
            
            let keys = Object.keys(groups).map(Number).sort((a,b)=>a-b);
            for(let i=0; i<keys.length-1; i++){
                let g1 = groups[keys[i]];
                let g2 = groups[keys[i+1]];
                g1.forEach(t1 => {
                    g2.forEach(t2 => {
                        let comb = combineTerms(t1.term, t2.term);
                        if(comb){
                            t1.used = true; t2.used = true;
                            if(!nextTerms.some(nt => nt.term === comb)){
                                // Fusionar llistes de minterms
                                let allMinterms = [...new Set([...t1.minterms, ...t2.minterms])];
                                nextTerms.push({ term: comb, minterms: allMinterms, used: false });
                            }
                        }
                    });
                });
            }
            primes.push(...terms.filter(t => !t.used));
            terms = nextTerms;
            if(terms.length === 0) break;
        }
        primes.push(...terms); // Afegir els últims

        // Eliminar duplicats
        let uniquePrimes = [];
        let seen = new Set();
        primes.forEach(p => {
            if(!seen.has(p.term)) { seen.add(p.term); uniquePrimes.push(p); }
        });

        // Selecció Greedy (per simplificar UI)
        let solution = [];
        let covered = new Set();
        
        // Prioritat: agafar els que cobreixen més 1s NO coberts encara
        while(true) {
            // Filtrar només els 1s reals (no X) que falten per cobrir
            let remainingOnes = ones.filter(x => !covered.has(x));
            if(remainingOnes.length === 0) break;

            let bestTerm = null;
            let maxCover = -1;

            uniquePrimes.forEach(p => {
                let count = 0;
                p.minterms.forEach(m => {
                    if(remainingOnes.includes(m)) count++;
                });
                if(count > maxCover) { maxCover = count; bestTerm = p; }
            });

            if(bestTerm && maxCover > 0) {
                solution.push(bestTerm);
                bestTerm.minterms.forEach(m => covered.add(m));
            } else {
                break; // Seguretat
            }
        }
        return solution;
    }

    function termToString(termStr) {
        if(termStr === '----') return '1';
        let s = '';
        for(let i=0; i<4; i++) {
            if(termStr[i] !== '-') s += variables[i] + (termStr[i] === '0' ? "'" : '');
        }
        return s;
    }

    // --- GUI ---

    let currentSolution = [];

    function update() {
        const ones = cells.map((v, i) => v === 1 ? i : -1).filter(i => i !== -1);
        const dontCares = cells.map((v, i) => v === 2 ? i : -1).filter(i => i !== -1);

        // Calcular solució
        currentSolution = solveKMap(ones, dontCares);
        
        // 1. Text Resultat
        const exprEl = document.getElementById('simplified-expr');
        if(ones.length === 0) exprEl.textContent = '0';
        else exprEl.textContent = currentSolution.map(s => termToString(s.term)).join(' + ');

        // 2. Dibuixar Mapa (amb els nous colors)
        drawMap();

        // 3. Generar Targetes Explicatives
        renderCards(ones);
    }

    function drawMap() {
        const container = document.getElementById('kmap-container');
        container.innerHTML = '';
        const cellSize = 60;
        const width = cellSize * 5;
        const height = cellSize * 5;

        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        
        // Etiquetes
        const labels = ["00", "01", "11", "10"];
        
        // Text diagonal
        const diag = document.createElementNS("http://www.w3.org/2000/svg", "text");
        diag.setAttribute("x", 25); diag.setAttribute("y", 35);
        diag.textContent = "AB\\CD";
        diag.setAttribute("font-size", "12");
        svg.appendChild(diag);

        // Capçaleres
        labels.forEach((l, i) => {
            // Top
            let t = document.createElementNS("http://www.w3.org/2000/svg", "text");
            t.setAttribute("x", (i+1.5)*cellSize); t.setAttribute("y", 35);
            t.setAttribute("text-anchor", "middle"); t.textContent = l;
            svg.appendChild(t);
            // Left
            t = document.createElementNS("http://www.w3.org/2000/svg", "text");
            t.setAttribute("x", 30); t.setAttribute("y", (i+1.6)*cellSize);
            t.setAttribute("text-anchor", "middle"); t.textContent = l;
            svg.appendChild(t);
        });

        // Dibuixar Cel·les
        for(let r=0; r<4; r++) {
            for(let c=0; c<4; c++) {
                const cellIndex = (rowGray[r] << 2) | colGray[c];
                const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                g.setAttribute('transform', `translate(${(c+1)*cellSize}, ${(r+1)*cellSize})`);
                
                // Rect
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute('width', cellSize); rect.setAttribute('height', cellSize);
                rect.setAttribute('class', 'cell-rect');
                rect.setAttribute('id', `cell-bg-${cellIndex}`);
                rect.addEventListener('click', () => toggleCell(cellIndex));
                g.appendChild(rect);

                // Valor (0, 1, X)
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute('x', cellSize/2); text.setAttribute('y', cellSize/2 + 8);
                text.setAttribute('text-anchor', "middle");
                text.setAttribute('class', 'cell-value');
                const val = cells[cellIndex];
                text.textContent = val === 2 ? 'X' : val;
                text.setAttribute('fill', val === 1 ? '#000' : '#ccc');
                g.appendChild(text);

                // --- SISTEMA DE MARCATGE PER COLORS ---
                // Mirem a quins grups pertany aquesta cel·la
                let dotOffset = 0;
                const dotSize = 8;
                const gap = 4;
                
                // Centrar els punts horitzontalment: Calculem quants n'hi ha primer
                const activeGroups = currentSolution.filter(sol => sol.minterms.includes(cellIndex));
                const totalWidth = activeGroups.length * (dotSize + gap) - gap;
                let startX = (cellSize - totalWidth) / 2;

                activeGroups.forEach((sol, solIdx) => {
                    // Trobem l'index global de la solució per assignar color consistent
                    const colorIdx = currentSolution.indexOf(sol) % palette.length;
                    const color = palette[colorIdx].color;

                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute('cx', startX + dotSize/2);
                    circle.setAttribute('cy', cellSize - 12); // A la part inferior
                    circle.setAttribute('r', dotSize/2);
                    circle.setAttribute('fill', color);
                    g.appendChild(circle);

                    startX += dotSize + gap;
                });

                svg.appendChild(g);
            }
        }
        container.appendChild(svg);
    }

    function renderCards(ones) {
        const container = document.getElementById('step-by-step');
        container.innerHTML = '';

        if(ones.length === 0) {
            container.innerHTML = '<div class="text-center text-muted py-5"><i class="fas fa-mouse-pointer fa-2x mb-3"></i><p>Afegeix 1s al mapa.</p></div>';
            return;
        }

        currentSolution.forEach((sol, idx) => {
            const p = palette[idx % palette.length];
            const termText = termToString(sol.term);
            
            // Analisi del canvi
            let analysis = '';
            ['A','B','C','D'].forEach((v, i) => {
                if(sol.term[i] === '-') analysis += `<span class="badge bg-light text-secondary border me-1" style="text-decoration: line-through">${v}</span>`;
                else analysis += `<span class="badge bg-white text-dark border me-1 fw-bold">${v}${sol.term[i]==='0'?"'":""}</span>`;
            });

            const div = document.createElement('div');
            div.className = 'explanation-card p-3 mb-3 bg-white rounded shadow-sm';
            div.style.borderLeftColor = p.color;
            div.innerHTML = `
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h5 class="mb-0 font-monospace" style="color:${p.color}">${termText}</h5>
                    <span class="badge rounded-pill bg-light text-dark border">Grup de ${sol.minterms.length}</span>
                </div>
                <div class="small mb-2">
                    Variables: ${analysis}
                </div>
                <div class="text-muted extra-small" style="font-size: 0.85rem">
                    <i class="fas fa-info-circle text-primary"></i> 
                    Les cel·les d'aquest grup tenen un <strong>punt de color ${getColorName(idx)}</strong>.
                </div>
            `;
            
            // Events hover
            div.addEventListener('mouseenter', () => highlightGroup(sol.minterms, p.bg));
            div.addEventListener('mouseleave', () => clearHighlights());

            container.appendChild(div);
        });
    }

    function getColorName(i) {
        const names = ['Vermell', 'Blau', 'Verd', 'Taronja', 'Lila'];
        return names[i % names.length];
    }

    function highlightGroup(indices, colorBg) {
        indices.forEach(idx => {
            const rect = document.getElementById(`cell-bg-${idx}`);
            if(rect) rect.setAttribute('fill', colorBg);
        });
    }

    function clearHighlights() {
        document.querySelectorAll('.cell-rect').forEach(r => r.setAttribute('fill', 'white'));
    }

    function toggleCell(idx) {
        cells[idx] = (cells[idx] + 1) % 3;
        update();
    }
    function resetCells() { cells.fill(0); update(); }
    function randomize() { cells = cells.map(() => Math.floor(Math.random()*3)); update(); }

    // Init
    drawMap();
    update();

</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
