
<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <title>Simulador de portes l√≤giques IEC DIN (bin√†ries)</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Roboto, sans-serif;
        }
        body {
            background: #eef2f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            width: 100%;
            background: white;
            border-radius: 40px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
        }
        h1 {
            margin: 0 0 10px;
            font-weight: 600;
            font-size: 2.5rem;
            color: #0b1e33;
        }
        .subtitle {
            background: #e6edf5;
            padding: 12px 20px;
            border-radius: 60px;
            margin-bottom: 25px;
            font-size: 1.1rem;
            border-left: 6px solid #2563eb;
        }
        .subtitle code {
            background: #d1d9e8;
            padding: 4px 10px;
            border-radius: 30px;
        }
        .expr-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 25px;
        }
        .expr-input {
            flex: 3;
            min-width: 280px;
        }
        .expr-input label {
            font-weight: 600;
            display: block;
            margin-bottom: 6px;
        }
        .expr-row {
            display: flex;
            gap: 8px;
        }
        #exprInput {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid #b9c7da;
            border-radius: 60px;
            font-size: 1.2rem;
            font-family: 'Courier New', monospace;
            background: white;
        }
        #updateExpr {
            background: #1e2b3c;
            color: white;
            border: none;
            border-radius: 60px;
            padding: 0 30px;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            border: 2px solid #1e2b3c;
        }
        #updateExpr:hover {
            background: #0f172a;
        }
        .examples {
            flex: 1;
            min-width: 200px;
        }
        .examples label {
            font-weight: 600;
            display: block;
            margin-bottom: 6px;
        }
        .example-btns {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .example-btn {
            background: #e2eaf2;
            border: 1px solid #a0b8d0;
            border-radius: 40px;
            padding: 8px 16px;
            font-weight: 500;
            cursor: pointer;
            flex: 1 0 auto;
        }
        .example-btn:hover {
            background: #cbd9e8;
        }
        .switches {
            background: #e2eaf2;
            border-radius: 80px;
            padding: 25px 30px;
            margin: 25px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 40px;
        }
        .switch-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .switch-item .var-name {
            font-size: 2rem;
            font-weight: 700;
        }
        .toggle-switch {
            width: 80px;
            height: 40px;
            background: #b0c0d0;
            border-radius: 40px;
            border: 3px solid #7e92a8;
            position: relative;
            cursor: pointer;
            transition: 0.2s;
        }
        .toggle-switch.active {
            background: #2ecc71;
            border-color: #1f8b4c;
        }
        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 32px;
            height: 32px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .toggle-switch.active::after {
            left: 42px;
        }
        .state-label {
            font-weight: 600;
            background: #d3deed;
            padding: 4px 14px;
            border-radius: 40px;
        }
        .diagram-box {
            background: #0e1a2b;
            border-radius: 30px;
            padding: 25px;
            margin: 25px 0;
            color: white;
            overflow-x: auto;
        }
        .diagram-svg {
            display: block;
            margin: 0 auto;
            background: #102231;
            border-radius: 20px;
        }
        .output-area {
            background: #eef3f9;
            border-radius: 50px;
            padding: 20px 30px;
            display: flex;
            align-items: center;
            gap: 25px;
            margin-top: 20px;
            border: 2px solid #b0c7e0;
        }
        .led {
            width: 60px;
            height: 60px;
            border-radius: 60px;
            background: #b0c0d0;
            border: 4px solid #6f85a0;
            transition: 0.2s;
        }
        .led.on {
            background: #f7b731;
            border-color: #c47d0b;
            box-shadow: 0 0 25px #f39c12;
        }
        .output-value {
            font-size: 2.2rem;
            font-weight: 700;
        }
        .explain-box {
            background: #eef3f9;
            border-radius: 30px;
            padding: 25px;
            margin-top: 25px;
            border: 2px solid #b0c7e0;
        }
        .explain-box h3 {
            margin-top: 0;
        }
        .gate-detail {
            background: white;
            border-radius: 24px;
            padding: 15px 20px;
            margin-bottom: 15px;
            border-left: 10px solid #2563eb;
        }
        .gate-detail.active {
            border-left-color: #2ecc71;
            background: #eafaf1;
        }
        .wire-detail {
            display: inline-block;
            background: #d7e2f0;
            border-radius: 40px;
            padding: 5px 15px;
            margin: 4px 8px 4px 0;
            font-weight: 500;
        }
        .summary {
            background: #cfdeef;
            border-radius: 40px;
            padding: 15px 20px;
            font-weight: 500;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>‚ö° Portes l√≤giques IEC DIN ¬∑ Totes bin√†ries</h1>
    <div class="subtitle">
        <code> ! = NOT ¬∑ & = AND ¬∑ | = OR </code> 
        ‚Äî Ara cada AND i OR tenen exactament dues entrades (descomposici√≥ bin√†ria)
    </div>

    <!-- Expressi√≥ + exemples -->
    <div class="expr-panel">
        <div class="expr-input">
            <label>‚úèÔ∏è Expressi√≥ l√≤gica (f = ...)</label>
            <div class="expr-row">
                <input type="text" id="exprInput" value="(!a & b & c & !d) | (!a & d)">
                <button id="updateExpr">Generar</button>
            </div>
        </div>
        <div class="examples">
            <label>üìå Exemples r√†pids</label>
            <div class="example-btns">
                <button class="example-btn" data-expr="(!a & b & c & !d) | (!a & d)">1</button>
                <button class="example-btn" data-expr="a & b | c & !d">2</button>
                <button class="example-btn" data-expr="!(a & b)">3</button>
                <button class="example-btn" data-expr="a | b | c | !d">4</button>
            </div>
        </div>
    </div>

    <!-- Interruptors interactius -->
    <div class="switches">
        <div class="switch-item">
            <span class="var-name">a</span>
            <div class="toggle-switch" id="sw-a"></div>
            <span class="state-label" id="state-a">Obert</span>
        </div>
        <div class="switch-item">
            <span class="var-name">b</span>
            <div class="toggle-switch" id="sw-b"></div>
            <span class="state-label" id="state-b">Obert</span>
        </div>
        <div class="switch-item">
            <span class="var-name">c</span>
            <div class="toggle-switch" id="sw-c"></div>
            <span class="state-label" id="state-c">Obert</span>
        </div>
        <div class="switch-item">
            <span class="var-name">d</span>
            <div class="toggle-switch" id="sw-d"></div>
            <span class="state-label" id="state-d">Obert</span>
        </div>
    </div>

    <!-- Diagrama SVG (generat din√†micament) -->
    <div class="diagram-box" id="diagramContainer">
        <svg id="circuitSvg" class="diagram-svg" width="900" height="500" viewBox="0 0 900 500"></svg>
    </div>

    <!-- Sortida (LED) -->
    <div class="output-area">
        <div class="led" id="outputLed"></div>
        <div class="output-value" id="outputText">Sortida 0 (inactiva)</div>
    </div>

    <!-- Explicaci√≥ detallada -->
    <div class="explain-box" id="explainBox">
        <h3>üîç Raonament detallat (circuit binari)</h3>
        <div id="explainContent"></div>
    </div>
</div>

<script>
    (function() {
        // --- Estat dels interruptors
        let estats = { a: false, b: false, c: false, d: false };

        // --- Elements DOM
        const sw = {
            a: document.getElementById('sw-a'),
            b: document.getElementById('sw-b'),
            c: document.getElementById('sw-c'),
            d: document.getElementById('sw-d')
        };
        const stateLabel = {
            a: document.getElementById('state-a'),
            b: document.getElementById('state-b'),
            c: document.getElementById('state-c'),
            d: document.getElementById('state-d')
        };
        const exprInput = document.getElementById('exprInput');
        const updateBtn = document.getElementById('updateExpr');
        const svg = document.getElementById('circuitSvg');
        const outputLed = document.getElementById('outputLed');
        const outputText = document.getElementById('outputText');
        const explainContent = document.getElementById('explainContent');

        // --- Estructura del circuit (xarxa de portes)
        let inputNodes = {};      // map nom -> node
        let notNodes = {};        // map var -> node NOT
        let andGates = [];        // llista de nodes AND
        let orGates = [];         // llista de nodes OR
        let allNodes = [];        // tots els nodes (per dibuix)
        let outputNode = null;    // node final

        // --- Parseig de l'expressi√≥ (retorna llista de termes, cada terme √©s llista de {var, type})
        function parseExpression(expr) {
            expr = expr.replace(/\s/g, '');
            const parts = expr.split('|');
            return parts.map(part => {
                const factors = part.split('&');
                return factors.map(f => {
                    f = f.replace(/[()]/g, '');
                    if (f.startsWith('!')) {
                        return { var: f[1], type: 'NC' };
                    } else {
                        return { var: f, type: 'NO' };
                    }
                });
            });
        }

        // --- Classe Node per a la xarxa
        class Node {
            constructor(id, type, inputs = []) {
                this.id = id;
                this.type = type; // 'input', 'not', 'and', 'or'
                this.inputs = inputs; // array de refer√®ncies a Node
                this.output = undefined; // valor calculat
                // per dibuix
                this.x = 0;
                this.y = 0;
                this.depth = 0; // profunditat (dist√†ncia des d'entrades)
            }
        }

        // --- Construeix la xarxa de portes bin√†ries a partir dels termes
        function buildNetwork(terms) {
            // Reiniciar estructures
            inputNodes = {};
            notNodes = {};
            andGates = [];
            orGates = [];
            allNodes = [];

            // Crear nodes d'entrada per a, b, c, d
            for (let v of ['a','b','c','d']) {
                let node = new Node(v, 'input');
                inputNodes[v] = node;
                allNodes.push(node);
            }

            // Detectar variables que necessiten NOT
            const negatedVars = new Set();
            terms.forEach(term => {
                term.forEach(lit => {
                    if (lit.type === 'NC') negatedVars.add(lit.var);
                });
            });

            // Crear nodes NOT per a cada variable negada
            negatedVars.forEach(v => {
                let node = new Node(`not_${v}`, 'not', [inputNodes[v]]);
                notNodes[v] = node;
                allNodes.push(node);
            });

            // Per a cada terme, construir arbre AND binari
            const termOutputs = []; // nodes finals de cada terme

            terms.forEach((term, idx) => {
                // Convertir literals a nodes fulla
                const leaves = term.map(lit => {
                    if (lit.type === 'NO') return inputNodes[lit.var];
                    else return notNodes[lit.var];
                });

                if (leaves.length === 0) return; // no hauria
                if (leaves.length === 1) {
                    termOutputs.push(leaves[0]);
                } else {
                    // Combinar bin√†riament: left-associative
                    let current = leaves[0];
                    for (let i = 1; i < leaves.length; i++) {
                        let andNode = new Node(`and_${idx}_${i}`, 'and', [current, leaves[i]]);
                        andGates.push(andNode);
                        allNodes.push(andNode);
                        current = andNode;
                    }
                    termOutputs.push(current);
                }
            });

            // Construir arbre OR binari amb les sortides dels termes
            if (termOutputs.length === 0) {
                outputNode = new Node('or_final', 'or', []); // cas buit (no passa)
                allNodes.push(outputNode);
            } else if (termOutputs.length === 1) {
                outputNode = termOutputs[0]; // sense OR
            } else {
                let current = termOutputs[0];
                for (let i = 1; i < termOutputs.length; i++) {
                    let orNode = new Node(`or_${i}`, 'or', [current, termOutputs[i]]);
                    orGates.push(orNode);
                    allNodes.push(orNode);
                    current = orNode;
                }
                outputNode = current;
            }

            // Calcular profunditats (per al dibuix)
            computeDepths();
        }

        // --- Calcula la profunditat de cada node (dist√†ncia m√†xima des d'entrades)
        function computeDepths() {
            // Inicialitzar profunditats: inputs depth 0
            allNodes.forEach(n => { if (n.type === 'input') n.depth = 0; });

            let changed = true;
            while (changed) {
                changed = false;
                allNodes.forEach(n => {
                    if (n.type === 'input') return;
                    let maxInputDepth = Math.max(...n.inputs.map(inp => inp.depth), -1);
                    if (maxInputDepth + 1 > n.depth) {
                        n.depth = maxInputDepth + 1;
                        changed = true;
                    }
                });
            }
        }

        // --- Avaluaci√≥ recursiva del valor de sortida d'un node
        function evaluateNode(node) {
            if (node.output !== undefined) return node.output;
            if (node.type === 'input') {
                node.output = estats[node.id] ? 1 : 0;
            } else if (node.type === 'not') {
                node.output = evaluateNode(node.inputs[0]) === 1 ? 0 : 1;
            } else if (node.type === 'and') {
                node.output = (evaluateNode(node.inputs[0]) === 1 && evaluateNode(node.inputs[1]) === 1) ? 1 : 0;
            } else if (node.type === 'or') {
                node.output = (evaluateNode(node.inputs[0]) === 1 || evaluateNode(node.inputs[1]) === 1) ? 1 : 0;
            }
            return node.output;
        }

        // --- Actualitza tots els valors (neteja cau i avalua)
        function evaluateAll() {
            allNodes.forEach(n => n.output = undefined);
            if (outputNode) evaluateNode(outputNode);
        }

        // --- Dibuixa el circuit SVG
        function dibuixaCircuit() {
            svg.setAttribute('width', 900);
            svg.setAttribute('height', 500);
            svg.setAttribute('viewBox', '0 0 900 500');
            svg.innerHTML = '';

            // Posicions fixes per a entrades (mateixes que abans)
            const yPos = { a: 80, b: 160, c: 240, d: 320 };
            const startX = 50;      // columna entrades
            const notX = 150;        // columna NOTs

            // Assignar coordenades reals als nodes
            // 1) Entrades
            for (let v in inputNodes) {
                inputNodes[v].x = startX;
                inputNodes[v].y = yPos[v];
            }

            // 2) NOTs: mateixa y que la variable corresponent
            for (let v in notNodes) {
                notNodes[v].x = notX;
                notNodes[v].y = yPos[v];
            }

            // 3) AND i OR: col¬∑locar per profunditat
            // Agrupar per profunditat
            const depthGroups = {};
            allNodes.forEach(n => {
                if (n.type === 'input' || n.type === 'not') return;
                if (!depthGroups[n.depth]) depthGroups[n.depth] = [];
                depthGroups[n.depth].push(n);
            });

            // Ordenar profunditats
            const depths = Object.keys(depthGroups).map(Number).sort((a,b) => a-b);
            // Espaiat horitzontal
            const colSpacing = 100;
            // Per a cada profunditat, assignar x = notX + 50 + depth * colSpacing (comencem despr√©s de NOTs)
            depths.forEach(d => {
                const nodesAtDepth = depthGroups[d];
                // Assignar y distribuint verticalment per evitar solapaments (podem posar-los en ordre, per√≤ intentem alinear amb les entrades si possible)
                // Per simplificar, els posem en una columna amb separaci√≥ regular
                const startY = 100;
                const step = 60;
                nodesAtDepth.forEach((node, i) => {
                    node.x = notX + 50 + d * colSpacing;
                    node.y = startY + i * step;
                });
            });

            // Ara dibuixar elements

            // 1) Dibuixar entrades (cercles)
            for (let v in inputNodes) {
                const node = inputNodes[v];
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', 12);
                circle.setAttribute('fill', estats[v] ? '#2ecc71' : '#e74c3c');
                circle.setAttribute('stroke', 'white');
                circle.setAttribute('stroke-width', 2);
                svg.appendChild(circle);
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', node.x - 20);
                text.setAttribute('y', node.y + 5);
                text.setAttribute('fill', 'white');
                text.setAttribute('font-size', '16');
                text.setAttribute('font-weight', 'bold');
                text.textContent = v;
                svg.appendChild(text);
            }

            // 2) Dibuixar NOTs
            for (let v in notNodes) {
                const node = notNodes[v];
                // rectangle NOT
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', node.x - 20);
                rect.setAttribute('y', node.y - 15);
                rect.setAttribute('width', 40);
                rect.setAttribute('height', 30);
                rect.setAttribute('fill', '#334155');
                rect.setAttribute('stroke', 'white');
                rect.setAttribute('stroke-width', 2);
                svg.appendChild(rect);
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', node.x - 5);
                text.setAttribute('y', node.y + 5);
                text.setAttribute('fill', 'white');
                text.setAttribute('font-size', '16');
                text.setAttribute('text-anchor', 'middle');
                text.textContent = '1';
                svg.appendChild(text);
                // cercle sortida
                const circleOut = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circleOut.setAttribute('cx', node.x + 20);
                circleOut.setAttribute('cy', node.y);
                circleOut.setAttribute('r', 6);
                circleOut.setAttribute('fill', node.output ? '#2ecc71' : '#e74c3c');
                circleOut.setAttribute('stroke', 'white');
                svg.appendChild(circleOut);
                // l√≠nia d'entrada des de la variable
                const fromNode = inputNodes[v];
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', fromNode.x + 12);
                line.setAttribute('y1', fromNode.y);
                line.setAttribute('x2', node.x - 20);
                line.setAttribute('y2', node.y);
                line.setAttribute('stroke', fromNode.output ? '#2ecc71' : '#e74c3c');
                line.setAttribute('stroke-width', 3);
                svg.appendChild(line);
            }

            // 3) Dibuixar ANDs
            andGates.forEach(node => {
                const x = node.x;
                const y = node.y;
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x - 20);
                rect.setAttribute('y', y - 15);
                rect.setAttribute('width', 40);
                rect.setAttribute('height', 30);
                rect.setAttribute('fill', node.output ? '#0f3b1f' : '#334155');
                rect.setAttribute('stroke', 'white');
                rect.setAttribute('stroke-width', 2);
                svg.appendChild(rect);
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x - 5);
                text.setAttribute('y', y + 5);
                text.setAttribute('fill', 'white');
                text.setAttribute('font-size', '16');
                text.setAttribute('text-anchor', 'middle');
                text.textContent = '&';
                svg.appendChild(text);
                // cercle sortida
                const circleOut = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circleOut.setAttribute('cx', x + 20);
                circleOut.setAttribute('cy', y);
                circleOut.setAttribute('r', 6);
                circleOut.setAttribute('fill', node.output ? '#2ecc71' : '#e74c3c');
                circleOut.setAttribute('stroke', 'white');
                svg.appendChild(circleOut);

                // Dibuixar connexions d'entrada
                node.inputs.forEach((inp, i) => {
                    const fromX = inp.x + (inp.type === 'input' ? 12 : (inp.type === 'not' ? 20 : 20));
                    const fromY = inp.y;
                    const toX = x - 20;
                    const toY = y;
                    // l√≠nia horitzontal fins a x de la porta, despr√©s vertical
                    const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line1.setAttribute('x1', fromX);
                    line1.setAttribute('y1', fromY);
                    line1.setAttribute('x2', toX);
                    line1.setAttribute('y2', fromY);
                    line1.setAttribute('stroke', inp.output ? '#2ecc71' : '#e74c3c');
                    line1.setAttribute('stroke-width', 3);
                    svg.appendChild(line1);
                    const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line2.setAttribute('x1', toX);
                    line2.setAttribute('y1', fromY);
                    line2.setAttribute('x2', toX);
                    line2.setAttribute('y2', toY);
                    line2.setAttribute('stroke', inp.output ? '#2ecc71' : '#e74c3c');
                    line2.setAttribute('stroke-width', 3);
                    svg.appendChild(line2);
                });
            });

            // 4) Dibuixar ORs
            orGates.forEach(node => {
                const x = node.x;
                const y = node.y;
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x - 20);
                rect.setAttribute('y', y - 15);
                rect.setAttribute('width', 40);
                rect.setAttribute('height', 30);
                rect.setAttribute('fill', node.output ? '#0f3b1f' : '#334155');
                rect.setAttribute('stroke', 'white');
                rect.setAttribute('stroke-width', 2);
                svg.appendChild(rect);
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x - 5);
                text.setAttribute('y', y + 5);
                text.setAttribute('fill', 'white');
                text.setAttribute('font-size', '16');
                text.setAttribute('text-anchor', 'middle');
                text.textContent = '‚â•1';
                svg.appendChild(text);
                // cercle sortida
                const circleOut = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circleOut.setAttribute('cx', x + 20);
                circleOut.setAttribute('cy', y);
                circleOut.setAttribute('r', 6);
                circleOut.setAttribute('fill', node.output ? '#2ecc71' : '#e74c3c');
                circleOut.setAttribute('stroke', 'white');
                svg.appendChild(circleOut);

                // Connexions d'entrada
                node.inputs.forEach((inp, i) => {
                    const fromX = inp.x + (inp.type === 'input' ? 12 : (inp.type === 'not' ? 20 : 20));
                    const fromY = inp.y;
                    const toX = x - 20;
                    const toY = y;
                    const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line1.setAttribute('x1', fromX);
                    line1.setAttribute('y1', fromY);
                    line1.setAttribute('x2', toX);
                    line1.setAttribute('y2', fromY);
                    line1.setAttribute('stroke', inp.output ? '#2ecc71' : '#e74c3c');
                    line1.setAttribute('stroke-width', 3);
                    svg.appendChild(line1);
                    const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line2.setAttribute('x1', toX);
                    line2.setAttribute('y1', fromY);
                    line2.setAttribute('x2', toX);
                    line2.setAttribute('y2', toY);
                    line2.setAttribute('stroke', inp.output ? '#2ecc71' : '#e74c3c');
                    line2.setAttribute('stroke-width', 3);
                    svg.appendChild(line2);
                });
            });

            // 5) Sortida final (si outputNode no √©s una porta, pot ser un node fulla)
            if (outputNode) {
                let outX, outY;
                if (outputNode.type === 'input' || outputNode.type === 'not') {
                    outX = outputNode.x + (outputNode.type === 'input' ? 12 : 20);
                    outY = outputNode.y;
                } else {
                    outX = outputNode.x + 20;
                    outY = outputNode.y;
                }
                // allargar una mica cap a la dreta
                const finalX = 800;
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', outX);
                line.setAttribute('y1', outY);
                line.setAttribute('x2', finalX);
                line.setAttribute('y2', outY);
                line.setAttribute('stroke', outputNode.output ? '#2ecc71' : '#e74c3c');
                line.setAttribute('stroke-width', 4);
                svg.appendChild(line);
                // cercle final
                const circleFinal = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circleFinal.setAttribute('cx', finalX + 10);
                circleFinal.setAttribute('cy', outY);
                circleFinal.setAttribute('r', 10);
                circleFinal.setAttribute('fill', outputNode.output ? '#f7b731' : '#b0c0d0');
                circleFinal.setAttribute('stroke', 'white');
                svg.appendChild(circleFinal);
                const textF = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textF.setAttribute('x', finalX + 10);
                textF.setAttribute('y', outY - 15);
                textF.setAttribute('fill', 'white');
                textF.setAttribute('font-size', '14');
                textF.setAttribute('text-anchor', 'middle');
                textF.textContent = 'f';
                svg.appendChild(textF);
            }
        }

        // --- Genera explicaci√≥ detallada
        function generarExplicacio() {
            let html = '<div>';

            // Entrades
            html += '<div style="background:#d7e2f0; border-radius:40px; padding:10px 18px; margin-bottom:20px;">';
            html += '<strong>üìã Entrades:</strong> ';
            for (let v of ['a','b','c','d']) {
                html += `${v}=${estats[v] ? 1 : 0} `;
            }
            html += '</div>';

            // NOTs
            if (Object.keys(notNodes).length > 0) {
                html += '<div style="margin-bottom:15px;"><strong>üîπ Portes NOT:</strong></div>';
                for (let v in notNodes) {
                    const node = notNodes[v];
                    html += `<div class="gate-detail ${node.output ? 'active' : ''}">`;
                    html += `NOT de ${v}: entrada = ${estats[v] ? 1 : 0} ‚Üí sortida = ${node.output} `;
                    html += `(perqu√® NOT nega l'entrada)</div>`;
                }
            }

            // ANDs
            if (andGates.length > 0) {
                html += '<div style="margin-top:15px; margin-bottom:15px;"><strong>üîπ Portes AND (bin√†ries):</strong></div>';
                andGates.forEach((node, idx) => {
                    const in0 = node.inputs[0];
                    const in1 = node.inputs[1];
                    const val0 = in0.output;
                    const val1 = in1.output;
                    html += `<div class="gate-detail ${node.output ? 'active' : ''}">`;
                    html += `AND ${idx+1}: entrades = ${val0} i ${val1} ‚Üí sortida = ${node.output} `;
                    html += `(perqu√® AND necessita ambd√≥s 1)</div>`;
                });
            }

            // ORs
            if (orGates.length > 0) {
                html += '<div style="margin-top:15px; margin-bottom:15px;"><strong>üîπ Portes OR (bin√†ries):</strong></div>';
                orGates.forEach((node, idx) => {
                    const in0 = node.inputs[0];
                    const in1 = node.inputs[1];
                    const val0 = in0.output;
                    const val1 = in1.output;
                    html += `<div class="gate-detail ${node.output ? 'active' : ''}">`;
                    html += `OR ${idx+1}: entrades = ${val0} i ${val1} ‚Üí sortida = ${node.output} `;
                    html += `(n'hi ha prou amb un 1)</div>`;
                });
            }

            // Resum
            html += `<div class="summary" style="margin-top:20px;">`;
            html += `<strong>üîå Resultat final:</strong> f = ${outputNode ? outputNode.output : 0} ‚Üí `;
            html += (outputNode && outputNode.output) ? 'SORTIDA ACTIVA (1)' : 'SORTIDA INACTIVA (0)';
            html += `</div>`;

            html += '</div>';
            return html;
        }

        // --- Actualitza tota la interf√≠cie
        function actualitzarTot() {
            // Actualitzar aspecte dels interruptors
            for (let lletra in estats) {
                if (estats[lletra]) {
                    sw[lletra].classList.add('active');
                    stateLabel[lletra].innerText = 'Tancat (1)';
                } else {
                    sw[lletra].classList.remove('active');
                    stateLabel[lletra].innerText = 'Obert (0)';
                }
            }

            // Reavaluar tots els nodes
            evaluateAll();

            // Dibuixar circuit
            dibuixaCircuit();

            // Actualitzar LED i text de sortida
            const sortida = outputNode ? outputNode.output : 0;
            if (sortida) {
                outputLed.classList.add('on');
                outputText.innerText = 'Sortida 1 (activa) ‚ö°';
            } else {
                outputLed.classList.remove('on');
                outputText.innerText = 'Sortida 0 (inactiva) ‚óã';
            }

            // Actualitzar explicaci√≥
            explainContent.innerHTML = generarExplicacio();
        }

        // --- Carregar nova expressi√≥
        function carregarExpressio(expr) {
            exprInput.value = expr;
            const terms = parseExpression(expr);
            buildNetwork(terms);
            actualitzarTot();
        }

        // --- Assignar events
        for (let lletra in sw) {
            sw[lletra].addEventListener('click', () => {
                estats[lletra] = !estats[lletra];
                actualitzarTot(); // nom√©s canvia estats, no la xarxa
            });
        }

        updateBtn.addEventListener('click', () => {
            carregarExpressio(exprInput.value);
        });

        document.querySelectorAll('.example-btn').forEach(btn => {
            btn.addEventListener('click', e => {
                const expr = e.target.getAttribute('data-expr');
                carregarExpressio(expr);
            });
        });

        // --- Inicialitzar
        carregarExpressio(exprInput.value);
    })();
</script>
</body>
</html>



