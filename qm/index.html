<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simplificador LÃ²gic â€“ 4 variables (pas a pas didÃ ctic)</title>
    <style>
        body { font-family: system-ui, sans-serif; background:#f9fafb; margin:0; padding:20px; }
        .card { max-width:1000px; margin:auto; background:white; border-radius:12px; box-shadow:0 4px 20px rgba(0,0,0,0.08); padding:2rem; }
        h1 { margin-top:0; color:#1e293b; }
        .input-group { display:flex; flex-wrap:wrap; gap:12px; margin:1.5rem 0; }
        input { flex:1; min-width:320px; padding:12px 16px; font-family:monospace; font-size:1.1rem; border:2px solid #cbd5e1; border-radius:10px; }
        input:focus { border-color:#7c3aed; outline:none; box-shadow:0 0 0 3px rgba(124,58,237,0.15); }
        button { padding:10px 20px; border:none; border-radius:10px; font-weight:600; cursor:pointer; color:white; }
        #simplify { background:#7c3aed; }
        #simplify:hover { background:#6d28d9; }
        #random { background:#10b981; }
        #clear   { background:#ef4444; }
        #output { margin-top:2rem; }
        #steps { background:#f1f5f9; padding:1.5rem; border-radius:10px; line-height:1.6; font-family: 'Courier New', monospace; white-space: pre-wrap; overflow-x: auto; font-size:0.95rem; }
        #result { margin-top:1.5rem; padding:1.2rem; background:#111827; color:#e5e7eb; border-radius:10px; font-size:1.6rem; font-family:monospace; text-align:center; }
        .error  { color:#dc2626; background:#fee2e2; padding:1rem; border-radius:8px; }
        .step-title { font-weight:700; color:#2d3748; margin-top:1rem; font-size:1.1rem; border-bottom:1px solid #cbd5e1; padding-bottom:0.2rem; }
    </style>
</head>
<body>

<div class="card">
    <h1>ğŸ“˜ Simplificador LÃ²gic â€“ AprÃ¨n Quine-McCluskey pas a pas</h1>
    <p style="color:#64748b;">Introdueix una expressiÃ³ amb variables a, b, c, d (ex: a'bcd + ab' + a'bc'd').</p>

    <div class="input-group">
      <input id="expr" placeholder="Ex: a'b'c'd' + a'b'c'd + a'b'cd' + a'b'cd" value="a'b'c'd' + a'b'c'd + a'b'cd' + a'b'cd">
        <button id="random">ğŸ² AleatÃ²ria</button>
        <button id="simplify">âš¡ Simplifica</button>
        <button id="clear">ğŸ—‘ï¸ Neteja</button>
    </div>

    <div id="output">
        <div id="steps">Prem Â«SimplificaÂ» per comenÃ§ar la classe interactivaâ€¦</div>
        <div id="result">â€”</div>
    </div>
</div>

<script>
// ------------------------------------------------------------
// Funcions auxiliars (mateixes que abans)
// ------------------------------------------------------------
const product = (s1, s2) => s1.flatMap(elt1 => s2.map(elt2 => [...elt1, ...elt2]));
const power = (s, p) => new Array(p).fill(s).reduce(product, [[]]);
const bool = [[0], [1]];

// ------------------------------------------------------------
// Format d'un terme (ex: "101-" -> "ab'c")
// ------------------------------------------------------------
function format_term(term, var_names) {
    if (!term) return '';
    let result = '';
    for (let i = 0; i < term.length; i++) {
        const c = term[i];
        if (c === '1') {
            result += var_names[i];
        } else if (c === '0') {
            result += var_names[i] + "'";
        }
        // '-' no s'escriu
    }
    return result || '1';   // si tot sÃ³n '-', Ã©s sempre cert
}

// ------------------------------------------------------------
// FunciÃ³ per dibuixar una petita taula d'agrupaciÃ³ (versiÃ³ textual)
// ------------------------------------------------------------
function formatGroupTable(grouped, var_names) {
    let lines = [];
    lines.push("--------------------------------------------------");
    lines.push("Grup (nÂº uns) | Termes (binari i expressiÃ³)");
    lines.push("--------------------------------------------------");
    grouped.forEach((g, i) => {
        if (g.length > 0) {
            let termsStr = g.map(t => t + " (" + format_term(t, var_names) + ")").join(', ');
            lines.push(`      ${i}         | ${termsStr}`);
        }
    });
    lines.push("--------------------------------------------------");
    return lines.join('\n');
}

// ------------------------------------------------------------
// Quine-McCluskey amb passos hiperdidÃ ctics (versiÃ³ simplificada perÃ² funcional)
// ------------------------------------------------------------
function Quine_McCluskey_with_steps(f, n_vars, var_names) {
    const steps = [];
    const fmt = (term) => format_term(term, var_names);

    // ---------- OBTENIR MINTERMS ----------
    const min_terms = power(bool, n_vars)
        .filter(e => f(...e) === 1)
        .map(e => e.join(''));

    steps.push(`ğŸ”¹ <span class="step-title">Pas 1: Minterms (combinacions on la funciÃ³ val 1)</span>`);
    steps.push(`   En binari (abcd): ${min_terms.join(', ')}`);
    steps.push(`   En decimal: ${min_terms.map(b => parseInt(b,2)).join(', ')}`);

    // ---------- FUNCIÃ“ PER TROBAR IMPLICANTS PRIMERS ----------
    const get_prime_implicants = (minterms) => {
        const number_of_1s = (s) => s.split('').reduce((acc, c) => acc + (c === '1' ? 1 : 0), 0);
        const hamming_distance = (s1, s2) => s1.split('').reduce((acc, c, i) => acc + (c !== s2.charAt(i) ? 1 : 0), 0);
        const different_index = (s1, s2) => s1.split('').findIndex((c, i) => c !== s2.charAt(i));
        const replace_at = (s, i, r) => s.substring(0, i) + r + s.substring(i + r.length);

        const primes = new Set();
        let terms = new Set(minterms);
        let iteration = 1;

        steps.push(`\nğŸ”¹ <span class="step-title">Pas 2: Combinacions per trobar implicants primers</span>`);

        while (terms.size > 0) {
            steps.push(`\n   <span class="step-title">IteraciÃ³ ${iteration}:</span>`);
            const grouped_terms = new Array(n_vars + 1).fill(null).map(_ => []);
            terms.forEach(t => grouped_terms[number_of_1s(t)].push(t));

            steps.push(`   AgrupaciÃ³ per nombre d'uns:`);
            steps.push(formatGroupTable(grouped_terms, var_names));

            const next_terms = new Set();
            const combined = new Set();

            for (let i = 0; i < grouped_terms.length - 1; i++) {
                const groupA = grouped_terms[i];
                const groupB = grouped_terms[i+1];
                if (groupA.length === 0 || groupB.length === 0) continue;

                steps.push(`   ğŸ”¸ Comparant grup ${i} i grup ${i+1}:`);

                groupA.forEach(t1 => groupB.forEach(t2 => {
                    const dist = hamming_distance(t1, t2);
                    if (dist === 1) {
                        const idx = different_index(t1, t2);
                        const newTerm = replace_at(t1, idx, '-');
                        steps.push(`      âœ… ${t1} (${fmt(t1)}) i ${t2} (${fmt(t2)}) -> ${newTerm} (${fmt(newTerm)})`);
                        combined.add(t1);
                        combined.add(t2);
                        next_terms.add(newTerm);
                    } else {
                        steps.push(`      âŒ ${t1} i ${t2} (distÃ ncia ${dist}) no es poden combinar.`);
                    }
                }));
            }

            const newPrimes = Array.from(terms).filter(t => !combined.has(t));
            if (newPrimes.length > 0) {
                steps.push(`   ğŸŸ¢ Implicants primers trobats: ${newPrimes.map(p => p + ' (' + fmt(p) + ')').join(', ')}`);
                newPrimes.forEach(p => primes.add(p));
            }

            if (next_terms.size > 0) {
                steps.push(`   Termes per a segÃ¼ent iteraciÃ³: ${Array.from(next_terms).map(t => t + ' (' + fmt(t) + ')').join(', ')}`);
            } else {
                steps.push(`   No hi ha termes per a una altra iteraciÃ³.`);
            }

            terms = next_terms;
            iteration++;
        }

        steps.push(`\n   <span class="step-title">Implicants primers finals:</span>`);
        Array.from(primes).forEach(p => steps.push(`   - ${p} (${fmt(p)})`));

        return primes;
    };

    const prime_implicants = get_prime_implicants(min_terms);

    // ---------- TAULA DE COBERTURA ----------
    const implicant_to_function = i => (...x) => i.split('').reduce((acc, c, i) => acc * (c === '-' ? 1 : +c === x[i]), 1);

    steps.push(`\nğŸ”¹ <span class="step-title">Pas 3: Taula de cobertura</span>`);
    steps.push(`Per a cada minterm, mirem quins implicants primers el cobreixen:`);

    min_terms.forEach(mt => {
        const bits = mt.split('').map(Number);
        const covering = Array.from(prime_implicants).filter(imp => implicant_to_function(imp)(...bits) === 1);
        steps.push(`   Minterm ${mt} cobert per: ${covering.map(c => fmt(c)).join(', ') || 'cap'}`);
    });

    // ---------- IMPLICANTS ESSENCIALS ----------
    steps.push(`\nğŸ”¹ <span class="step-title">Pas 4: Implicants primers essencials</span>`);
    steps.push(`Un implicant Ã©s essencial si algun minterm nomÃ©s Ã©s cobert per ell.`);

    const essential_prime_implicants = new Set();
    min_terms.forEach(mt => {
        const bits = mt.split('').map(Number);
        const covering = Array.from(prime_implicants).filter(imp => implicant_to_function(imp)(...bits) === 1);
        if (covering.length === 1) {
            essential_prime_implicants.add(covering[0]);
            steps.push(`   âœ… Minterm ${mt} nomÃ©s cobert per ${fmt(covering[0])} â†’ essencial.`);
        } else if (covering.length > 1) {
            steps.push(`   ğŸ”¸ Minterm ${mt} tÃ© ${covering.length} cobertures: ${covering.map(c => fmt(c)).join(', ')}`);
        }
    });

    if (essential_prime_implicants.size > 0) {
        steps.push(`\n   Essencials: ${Array.from(essential_prime_implicants).map(i => fmt(i)).join(', ')}`);
    } else {
        steps.push(`   No hi ha essencials.`);
    }

    // ---------- MINTERMS RESTANTS ----------
    const remaining_min_terms = min_terms.filter(mt => {
        const bits = mt.split('').map(Number);
        return !Array.from(essential_prime_implicants).some(imp => implicant_to_function(imp)(...bits) === 1);
    });

    const remaining_implicants = Array.from(prime_implicants).filter(i => !essential_prime_implicants.has(i));

    if (remaining_min_terms.length > 0) {
        steps.push(`\nğŸ”¹ <span class="step-title">Pas 5: Minterms encara no coberts</span>`);
        steps.push(`   Queden: ${remaining_min_terms.join(', ')}`);
        steps.push(`   Implicants disponibles: ${remaining_implicants.map(i => fmt(i)).join(', ')}`);

        // MÃ¨tode de Petrick simplificat: triam la combinaciÃ³ que cobreixi tots els minterms restants amb el menor nombre d'implicants
        steps.push(`\nğŸ”¹ <span class="step-title">Pas 6: Cobertura mÃ­nima (mÃ¨tode de Petrick simplificat)</span>`);

        // FunciÃ³ per comprovar si un conjunt d'implicants cobreix tots els minterms restants
        const coversAll = (implicantsSet) => {
            return remaining_min_terms.every(mt => {
                const bits = mt.split('').map(Number);
                return implicantsSet.some(imp => implicant_to_function(imp)(...bits) === 1);
            });
        };

        // Generam totes les combinacions possibles d'implicants restants (pot ser costÃ³s si n'hi ha molts, perÃ² per a 4 variables no hauria de ser problema)
        const allCombinations = [];
        const k = remaining_implicants.length;
        // Generar mÃ scares de bits per a totes les combinacions no buides
        for (let mask = 1; mask < (1 << k); mask++) {
            const comb = [];
            for (let i = 0; i < k; i++) {
                if (mask & (1 << i)) comb.push(remaining_implicants[i]);
            }
            allCombinations.push(comb);
        }

        // Ordenar per nombre d'implicants (menor primer)
        allCombinations.sort((a, b) => a.length - b.length);

        // Trobar la primera combinaciÃ³ que cobreixi tots
        let bestCover = null;
        for (let comb of allCombinations) {
            if (coversAll(comb)) {
                bestCover = comb;
                break;
            }
        }

        if (bestCover) {
            steps.push(`   La millor combinaciÃ³ trobada Ã©s: ${bestCover.map(i => fmt(i)).join(' + ')}`);
            const finalImplicants = [...essential_prime_implicants, ...bestCover];
            steps.push(`\nğŸ”¹ <span class="step-title">Pas 7: ExpressiÃ³ final</span>`);
            steps.push(`   ${finalImplicants.map(i => fmt(i)).join(' + ')}`);
            return { steps, solutions: [finalImplicants] };
        } else {
            steps.push(`   No s'ha trobat una combinaciÃ³ que cobreixi tots. AixÃ² no hauria de passar.`);
            return { steps, solutions: [[...essential_prime_implicants]] };
        }
    } else {
        // Tots coberts pels essencials
        steps.push(`\nğŸ”¹ <span class="step-title">Pas 5: ExpressiÃ³ final</span>`);
        steps.push(`   ${Array.from(essential_prime_implicants).map(i => fmt(i)).join(' + ') || '0'}`);
        return { steps, solutions: [[...essential_prime_implicants]] };
    }
}

// ------------------------------------------------------------
// Parser d'entrada (text -> llista de minterms 0-15)
// ------------------------------------------------------------
function parseToMinterms(str) {
    str = str.replace(/\s+/g, '').trim();
    if (!str) throw new Error("ExpressiÃ³ buida");

    const vars = ['a', 'b', 'c', 'd'];
    const terms = str.split('+').filter(Boolean);
    const minterms = new Set();

    for (let term of terms) {
        let mask = 0, care = 0;
        let i = 0;
        while (i < term.length) {
            let ch = term[i++];
            let idx = vars.indexOf(ch);
            if (idx === -1) throw new Error(`Variable invÃ lida: ${ch}`);
            let negated = (i < term.length && term[i] === "'");
            if (negated) i++;
            let bit = negated ? 0 : 1;
            mask |= (bit << (3 - idx));
            care |= (1 << (3 - idx));
        }
        for (let val = 0; val < 16; val++) {
            if ((val & care) === mask) minterms.add(val);
        }
    }
    return [...minterms].sort((a, b) => a - b);
}

// ------------------------------------------------------------
// Defineix la funciÃ³ booleana a partir dels minterms
// ------------------------------------------------------------
function defineF(minterms) {
    return (...bits) => {
        const val = bits.reduce((acc, b, i) => acc | (b << (3 - i)), 0);
        return minterms.includes(val) ? 1 : 0;
    };
}

// ------------------------------------------------------------
// Esdeveniments de la interfÃ­cie
// ------------------------------------------------------------
document.addEventListener('DOMContentLoaded', () => {
    const exprEl = document.getElementById('expr');
    const stepsEl = document.getElementById('steps');
    const resEl = document.getElementById('result');

    document.getElementById('simplify').onclick = () => {
        try {
            const minterms = parseToMinterms(exprEl.value);
            const f = defineF(minterms);
            const var_names = ['a', 'b', 'c', 'd'];

            const { steps, solutions } = Quine_McCluskey_with_steps(f, 4, var_names);

            stepsEl.innerHTML = steps.join('<br>');

            // Mostrar resultat (primera soluciÃ³)
            const simplified = solutions[0].map(i => format_term(i, var_names)).join(' + ') || '0';
            resEl.textContent = simplified;
            resEl.style.background = '#065f46';
        } catch (e) {
            stepsEl.innerHTML = `<div class="error">Error: ${e.message}</div>`;
            resEl.textContent = 'â€”';
            resEl.style.background = '#991b1b';
        }
    };

    document.getElementById('clear').onclick = () => {
        exprEl.value = '';
        stepsEl.innerHTML = 'Prem Â«SimplificaÂ» per comenÃ§ar la classe interactivaâ€¦';
        resEl.textContent = 'â€”';
        resEl.style.background = '#111827';
    };

    document.getElementById('random').onclick = () => {
        const n = Math.floor(Math.random() * 4) + 3;
        let terms = [];
        for (let i = 0; i < n; i++) {
            let t = '';
            for (let v of ['a', 'b', 'c', 'd']) {
                if (Math.random() > 0.35) {
                    t += v;
                    if (Math.random() > 0.5) t += "'";
                }
            }
            if (t) terms.push(t);
        }
        exprEl.value = terms.join(' + ') || "a'b + ab";
    };

    // Executa l'exemple inicial
    document.getElementById('simplify').click();
});
</script>
</body>
</html>
