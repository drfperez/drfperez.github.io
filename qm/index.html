<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simplificador LÃ²gic â€“ 4 variables (pas a pas)</title>
    <style>
        body { font-family: system-ui, sans-serif; background:#f9fafb; margin:0; padding:20px; }
        .card { max-width:960px; margin:auto; background:white; border-radius:12px; box-shadow:0 4px 20px rgba(0,0,0,0.08); padding:2rem; }
        h1 { margin-top:0; color:#1e293b; }
        .input-group { display:flex; flex-wrap:wrap; gap:12px; margin:1.5rem 0; }
        input { flex:1; min-width:320px; padding:12px 16px; font-family:monospace; font-size:1.1rem; border:2px solid #cbd5e1; border-radius:10px; }
        input:focus { border-color:#7c3aed; outline:none; box-shadow:0 0 0 3px rgba(124,58,237,0.15); }
        button { padding:10px 20px; border:none; border-radius:10px; font-weight:600; cursor:pointer; color:white; }
        #simplify { background:#7c3aed; }
        #simplify:hover { background:#6d28d9; }
        #random { background:#10b981; }
        #clear   { background:#ef4444; }
        #output { margin-top:2rem; }
        #steps { background:#f1f5f9; padding:1.5rem; border-radius:10px; line-height:1.6; font-family: monospace; white-space: pre-wrap; overflow-x: auto; }
        #result { margin-top:1.5rem; padding:1.2rem; background:#111827; color:#e5e7eb; border-radius:10px; font-size:1.6rem; font-family:monospace; text-align:center; }
        .error  { color:#dc2626; background:#fee2e2; padding:1rem; border-radius:8px; }
        .step-title { font-weight:700; color:#2d3748; margin-top:0.75rem; }
        .badge { background:#7c3aed20; color:#4c1d95; padding:0.2rem 0.5rem; border-radius:20px; font-size:0.8rem; }
    </style>
</head>
<body>

<div class="card">
    <h1>ğŸ” Simplificador LÃ²gic â€“ 4 variables (a b c d)</h1>
    <p style="color:#64748b;">Format: a'bcd + ab' + a'bc'd' + ...</p>

    <div class="input-group">
        <input id="expr" placeholder="Ex: a'bcd + ab'cd + abc'd + abcd'" value="a'bcd + ab'cd + abc'd + abcd'">
        <button id="random">ğŸ² AleatÃ²ria</button>
        <button id="simplify">âš¡ Simplifica</button>
        <button id="clear">ğŸ—‘ï¸ Neteja</button>
    </div>

    <div id="output">
        <div id="steps">Prem Â«SimplificaÂ» per veure el procÃ©s pas a pasâ€¦</div>
        <div id="result">â€”</div>
    </div>
</div>

<script>
// ------------------------------------------------------------
// Funcions auxiliars (Ã lgebra booleana, producte cartesiÃ , etc.)
// ------------------------------------------------------------
const product = (s1, s2) => s1.flatMap(elt1 => s2.map(elt2 => [...elt1, ...elt2]));
const power = (s, p) => new Array(p).fill(s).reduce(product, [[ ]]);
const bool = [[0], [1]];

const and = (...x) => { const base = (x, y) => x * y; return x.reduce(base, 1) };
const or = (...x) => { const base = (x, y) => x + y - x * y; return x.reduce(base, 0) };
const xor = (...x) => { const base = (x, y) => x + y - 2 * x * y; return x.reduce(base, 0) };
const nand = (...x) => 1 - and(...x);

const dual_func = f => (...x) => (v => v === '*' ? '*' : 1 - v)(f(...x.map(t => 1 - t)));
const equals = (f, g, n_vars = f.length) => power(bool, n_vars)
  .every(elt => ((v1, v2) => v1 === '*' || v2 === '*' ? true : v1 === v2)(f(...elt), g(...elt)))
  ? 1 : 0;

// ------------------------------------------------------------
// Format d'un terme (ex: "101-" -> "ab'c")
// ------------------------------------------------------------
function format_term(term, var_names) {
    if (!term) return '';
    let result = '';
    for (let i = 0; i < term.length; i++) {
        const c = term[i];
        if (c === '1') {
            result += var_names[i];
        } else if (c === '0') {
            result += var_names[i] + "'";
        }
        // '-' no s'escriu
    }
    return result || '1';   // si tot sÃ³n '-', Ã©s sempre cert
}

// ------------------------------------------------------------
// Quine-McCluskey amb generaciÃ³ de passos didÃ ctics
// ------------------------------------------------------------
function Quine_McCluskey_with_steps(f, n_vars, var_names) {
    const steps = [];
    const fmt = (term) => format_term(term, var_names);

    // ---------- Obtenir implicants primos (amb passos) ----------
    const get_prime_implicants = (f, n_vars) => {
        const number_of_1s = (s) => s.split('').reduce((acc, c) => acc + (c === '1' ? 1 : 0), 0);
        const hamming_distance = (s1, s2) => s1.split('').reduce((acc, c, i) => acc + (c !== s2.charAt(i) ? 1 : 0), 0);
        const different_index = (s1, s2) => s1.split('').findIndex((c, i) => c !== s2.charAt(i));
        const replace_at = (s, i, r) => s.substring(0, i) + r + s.substring(i + r.length);

        const primes = new Set();

        const min_terms = power(bool, n_vars)
            .filter(e => f(...e) === 1 || f(...e) === '*')
            .map(e => e.join(''));
        steps.push(`<span class="step-title">ğŸ”¹ Pas 1:</span> Minterms (on la funciÃ³ val 1) en binari:`);
        steps.push(`   ${min_terms.join(', ')}`);

        let terms = new Set(min_terms);
        let iteration = 1;
        while (terms.size > 0) {
            steps.push(`\n<span class="step-title">   IteraciÃ³ ${iteration}:</span>`);
            const grouped_terms = new Array(n_vars + 1).fill(null).map(_ => []);
            terms.forEach(t => grouped_terms[number_of_1s(t)].push(t));

            // Mostrar agrupaciÃ³
            steps.push(`   AgrupaciÃ³ per nombre d'uns:`);
            grouped_terms.forEach((g, i) => {
                if (g.length > 0) {
                    steps.push(`      Grup ${i}: ${g.join(', ')}`);
                }
            });

            const next_terms = new Set();
            const combined = new Set();

            for (let i = 0; i < grouped_terms.length - 1; i++) {
                grouped_terms[i].forEach(t1 => grouped_terms[i + 1].forEach(t2 => {
                    if (hamming_distance(t1, t2) === 1) {
                        combined.add(t1);
                        combined.add(t2);
                        const newTerm = replace_at(t1, different_index(t1, t2), '-');
                        next_terms.add(newTerm);
                    }
                }));
            }

            if (combined.size > 0) {
                steps.push(`   Termes combinats: ${Array.from(combined).join(', ')}`);
            }
            if (next_terms.size > 0) {
                steps.push(`   Nous termes generats: ${Array.from(next_terms).join(', ')}`);
            }

            const newPrimes = Array.from(terms).filter(t => !combined.has(t));
            if (newPrimes.length > 0) {
                steps.push(`   ğŸŸ¢ Implicants primos descoberts: ${newPrimes.map(t => fmt(t) + ' (' + t + ')').join(', ')}`);
                newPrimes.forEach(t => primes.add(t));
            }

            terms = next_terms;
            iteration++;
        }

        steps.push(`\n<span class="step-title">ğŸ”¹ Pas 2:</span> Implicants primos finals:`);
        steps.push(`   ${Array.from(primes).map(t => fmt(t) + ' (' + t + ')').join(', ')}`);
        return primes;
    };

    // ---------- ExecuciÃ³ principal ----------
    const prime_implicants = get_prime_implicants(f, n_vars);

    const implicant_to_function = i => (...x) => i.split('').reduce((acc, c, i) => acc * (c === '-' ? 1 : +c === x[i]), 1);

    const min_terms = power(bool, n_vars)
        .filter(e => f(...e) === 1)
        .map(e => e.join(''));

    // ---------- Essencials ----------
    steps.push(`\n<span class="step-title">ğŸ”¹ Pas 3:</span> DeterminaciÃ³ dels implicants primos essencials.`);
    const coverage = {};
    min_terms.forEach(t => {
        const applicable = Array.from(prime_implicants).filter(i => implicant_to_function(i)(...t.split('').map(Number)) === 1);
        coverage[t] = applicable.map(i => fmt(i));
        steps.push(`   Minterm ${t} cobert per: ${applicable.map(i => fmt(i) + ' (' + i + ')').join(', ') || 'cap'}`);
    });

    const essential_prime_implicants = new Set();
    min_terms.forEach(t => {
        const applicable_implicants = Array.from(prime_implicants).filter(i => implicant_to_function(i)(...t.split('').map(Number)) === 1);
        if (applicable_implicants.length === 1) {
            essential_prime_implicants.add(applicable_implicants[0]);
        }
    });

    if (essential_prime_implicants.size > 0) {
        steps.push(`   ğŸŸ¢ Essencials: ${Array.from(essential_prime_implicants).map(i => fmt(i) + ' (' + i + ')').join(', ')}`);
    } else {
        steps.push(`   No hi ha implicants primos essencials.`);
    }

    const remaining_implicants = Array.from(prime_implicants).filter(i => !essential_prime_implicants.has(i));
    const remaining_min_terms = min_terms.filter(t => Array.from(essential_prime_implicants).every(i => implicant_to_function(i)(...t.split('').map(Number)) === 0));

    if (remaining_min_terms.length > 0) {
        steps.push(`\n<span class="step-title">ğŸ”¹ Pas 4:</span> MintÃ¨rmims restants (no coberts pels essencials): ${remaining_min_terms.join(', ')}`);
        steps.push(`   Implicants primos restants: ${remaining_implicants.map(i => fmt(i) + ' (' + i + ')').join(', ')}`);
    } else {
        steps.push(`\n<span class="step-title">ğŸ”¹ Pas 4:</span> Tots els minterms estan coberts pels essencials.`);
    }

    // ---------- MÃ¨tode de Petrick ----------
    const petricks_method = (implicants, min_terms) => {
        steps.push(`\n<span class="step-title">ğŸ”¹ Pas 5:</span> MÃ¨tode de Petrick per a la cobertura mÃ­nima.`);

        const product_of_sums = min_terms.map(t => implicants.filter(i => implicant_to_function(i)(...t.split('').map(Number)) === 1));
        steps.push(`   Taula de cobertura (producte de sumes):`);
        min_terms.forEach((t, idx) => {
            steps.push(`      Minterm ${t} : ${product_of_sums[idx].map(i => fmt(i)).join(' + ') || 'cap'}`);
        });

        const sum_of_products = product_of_sums.map(sum => sum.map(i => [i])).reduce(product, [[ ]]);

        // Reduccions per idempotÃ¨ncia i absorciÃ³
        const reduce_by_mul_idempotency = product => [...new Set(product)];
        const reduce_by_add_idempotency = sum_of_products => {
            const reduced_str = new Set();
            const reduced = [];
            sum_of_products.forEach(product => {
                const str = product.sort().join('');
                if (reduced_str.has(str)) return;
                reduced_str.add(str);
                reduced.push(product);
            });
            return reduced;
        };
        const reduce_by_absorption = sum_of_products => {
            sum_of_products.sort((p1, p2) => p2.length - p1.length);
            const contains = (parent, child) => { const s = new Set(parent); return child.every(i => s.has(i)) };
            return sum_of_products.filter((parent, i_p) => sum_of_products.every((child, i_c) => i_c <= i_p || !contains(parent, child)));
        };

        let reduced = [
            sum_of_products => sum_of_products.map(product => reduce_by_mul_idempotency(product)),
            reduce_by_add_idempotency,
            reduce_by_absorption
        ].reduce((acc, f) => f(acc), sum_of_products);

        steps.push(`   DesprÃ©s de simplificar (idempotÃ¨ncia, absorciÃ³):`);
        reduced.forEach((cover, idx) => {
            steps.push(`      OpciÃ³ ${idx+1}: ${cover.map(i => fmt(i)).join(' + ')}`);
        });

        const fewest_implicants = reduced.reduce((acc, i) => Math.min(acc, i.length), Number.MAX_SAFE_INTEGER);
        const fewest_prime_implicants = reduced.filter(i => i.length === fewest_implicants);

        const number_of_literals = term => term.split('').reduce((acc, c) => acc + (c === '1' || c === '0' ? 1 : 0), 0);
        const number_of_literals_of_implicant = i => i.reduce((acc, term) => acc + number_of_literals(term), 0);
        const fewest_literals = fewest_prime_implicants
            .reduce((acc, i) => Math.min(acc, number_of_literals_of_implicant(i)), Number.MAX_SAFE_INTEGER);
        const best = fewest_prime_implicants.filter(i => number_of_literals_of_implicant(i) === fewest_literals);

        steps.push(`   âœ”ï¸ Millors opcions (${fewest_implicants} implicants, ${fewest_literals} literals):`);
        best.forEach((cover, idx) => {
            steps.push(`      * ${cover.map(i => fmt(i)).join(' + ')}`);
        });

        return best;
    };

    let chosen_rest_implicants = [[]];
    if (remaining_implicants.length > 0 && remaining_min_terms.length > 0) {
        chosen_rest_implicants = petricks_method(remaining_implicants, remaining_min_terms);
    } else {
        steps.push(`\n<span class="step-title">ğŸ”¹ Pas 5:</span> No calen mÃ©s implicants.`);
    }

    const solutions = chosen_rest_implicants.map(rest => [...essential_prime_implicants, ...rest]);

    steps.push(`\n<span class="step-title">âœ… Resultat final:</span>`);
    solutions.forEach((sol, idx) => {
        steps.push(`   ExpressiÃ³ ${idx+1}: ${sol.map(i => fmt(i)).join(' + ')}`);
    });

    return { steps, solutions };
}

// ------------------------------------------------------------
// Parser d'entrada (text -> llista de minterms 0-15)
// ------------------------------------------------------------
function parseToMinterms(str) {
    str = str.replace(/\s+/g, '').trim();
    if (!str) throw new Error("ExpressiÃ³ buida");

    const vars = ['a', 'b', 'c', 'd'];
    const terms = str.split('+').filter(Boolean);
    const minterms = new Set();

    for (let term of terms) {
        let mask = 0, care = 0; // bits fixos i mÃ scara de cura (MSB a, LSB d)
        let i = 0;
        while (i < term.length) {
            let ch = term[i++];
            let idx = vars.indexOf(ch);
            if (idx === -1) throw new Error(`Variable invÃ lida: ${ch}`);
            let negated = (i < term.length && term[i] === "'");
            if (negated) i++;
            let bit = negated ? 0 : 1;
            mask |= (bit << (3 - idx));
            care |= (1 << (3 - idx));
        }
        // Generar tots els minterms que encaixen
        for (let val = 0; val < 16; val++) {
            if ((val & care) === mask) minterms.add(val);
        }
    }
    return [...minterms].sort((a, b) => a - b);
}

// ------------------------------------------------------------
// Defineix la funciÃ³ booleana a partir dels minterms
// ------------------------------------------------------------
function defineF(minterms) {
    return (...bits) => {
        const val = bits.reduce((acc, b, i) => acc | (b << (3 - i)), 0);
        return minterms.includes(val) ? 1 : 0;
    };
}

// ------------------------------------------------------------
// Esdeveniments de la interfÃ­cie
// ------------------------------------------------------------
document.addEventListener('DOMContentLoaded', () => {
    const exprEl = document.getElementById('expr');
    const stepsEl = document.getElementById('steps');
    const resEl = document.getElementById('result');

    document.getElementById('simplify').onclick = () => {
        try {
            const minterms = parseToMinterms(exprEl.value);
            const f = defineF(minterms);
            const var_names = ['a', 'b', 'c', 'd'];

            const { steps, solutions } = Quine_McCluskey_with_steps(f, 4, var_names);

            // Mostrar passos
            stepsEl.innerHTML = steps.join('<br>');

            // Mostrar resultat (agafem la primera soluciÃ³)
            const simplified = solutions[0].map(i => format_term(i, var_names)).join(' + ') || '0';
            resEl.textContent = simplified;
            resEl.style.background = '#065f46';
        } catch (e) {
            stepsEl.innerHTML = `<div class="error">Error: ${e.message}</div>`;
            resEl.textContent = 'â€”';
            resEl.style.background = '#991b1b';
        }
    };

    document.getElementById('clear').onclick = () => {
        exprEl.value = '';
        stepsEl.innerHTML = 'Prem Â«SimplificaÂ» per veure el procÃ©s pas a pasâ€¦';
        resEl.textContent = 'â€”';
        resEl.style.background = '#111827';
    };

    document.getElementById('random').onclick = () => {
        const n = Math.floor(Math.random() * 4) + 3;
        let terms = [];
        for (let i = 0; i < n; i++) {
            let t = '';
            for (let v of ['a', 'b', 'c', 'd']) {
                if (Math.random() > 0.35) {
                    t += v;
                    if (Math.random() > 0.5) t += "'";
                }
            }
            if (t) terms.push(t);
        }
        exprEl.value = terms.join(' + ') || "a'b + ab";
    };

    // Executa l'exemple inicial
    document.getElementById('simplify').click();
});
</script>
</body>
</html>
