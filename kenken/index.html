<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Generador de KenKen</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
      color: #333;
      min-height: 100vh;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .container {
      max-width: 900px;
      width: 100%;
      background: rgba(255, 255, 255, 0.95);
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
    }
    
    header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    h1 {
      color: #2c3e50;
      font-size: 2.8rem;
      margin-bottom: 15px;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.1);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
    }
    
    .subtitle {
      color: #7f8c8d;
      font-size: 1.3rem;
      margin-bottom: 5px;
    }
    
    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      margin-bottom: 30px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 12px;
      box-shadow: 0 6px 12px rgba(0,0,0,0.05);
    }
    
    select, button {
      font-size: 1.1rem;
      padding: 12px 24px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
    }
    
    select {
      background-color: #e9ecef;
      color: #333;
      border: 1px solid #ced4da;
      min-width: 140px;
    }
    
    button {
      background: linear-gradient(to right, #3498db, #2c3e50);
      color: white;
      box-shadow: 0 6px 12px rgba(0,0,0,0.15);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      min-width: 200px;
    }
    
    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 15px rgba(0,0,0,0.2);
    }
    
    button:active {
      transform: translateY(1px);
    }
    
    #kenkenGrid {
      display: grid;
      margin: 30px auto;
      gap: 0;
      justify-content: center;
      border: 4px solid #2c3e50;
      background: #2c3e50;
      border-radius: 8px;
      box-shadow: 0 12px 25px rgba(0,0,0,0.25);
      position: relative;
      overflow: hidden;
    }
    
    .cell {
      position: relative;
      width: 50px;
      height: 50px;
      border: 1px solid #7f8c8d;
      font-size: 24px;
      text-align: center;
      vertical-align: middle;
      font-weight: bold;
      font-family: 'Courier New', monospace;
      background: white;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }
    
    .cell:hover {
      background-color: #f1f2f6;
    }
    
    .border-top-region { border-top: 4px solid #e74c3c !important; }
    .border-right-region { border-right: 4px solid #e74c3c !important; }
    .border-bottom-region { border-bottom: 4px solid #e74c3c !important; }
    .border-left-region { border-left: 4px solid #e74c3c !important; }
    
    .region-label {
      position: absolute;
      top: 4px;
      left: 4px;
      font-size: 13px;
      font-weight: bold;
      background: linear-gradient(to right, #e74c3c, #c0392b);
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      user-select: none;
      pointer-events: none;
      z-index: 10;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    #helpModal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.85);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    #helpContent {
      background: linear-gradient(to bottom, #f5f7fa, #e4e7ed);
      padding: 40px;
      border-radius: 15px;
      max-width: 750px;
      text-align: left;
      box-shadow: 0 20px 50px rgba(0,0,0,0.4);
      position: relative;
      overflow-y: auto;
      max-height: 90vh;
    }
    
    #helpContent h2 {
      margin-top: 0;
      color: #3498db;
      border-bottom: 3px solid #3498db;
      padding-bottom: 15px;
      margin-bottom: 20px;
    }
    
    #helpContent ul {
      list-style-type: none;
      padding-left: 0;
      margin: 20px 0;
    }
    
    #helpContent li {
      padding: 12px 0;
      border-bottom: 1px solid #dce1e6;
      display: flex;
      align-items: flex-start;
      font-size: 1.1rem;
    }
    
    #helpContent li:before {
      content: "‚Ä¢";
      color: #3498db;
      font-weight: bold;
      font-size: 1.5rem;
      display: inline-block; 
      width: 1.5em;
      margin-left: -1.5em;
    }
    
    #helpContent button {
      margin-top: 20px;
      background: linear-gradient(to right, #e74c3c, #c0392b);
      padding: 14px 30px;
      font-size: 1.2rem;
    }
    
    #helpContent button:hover {
      background: linear-gradient(to right, #c0392b, #a5281b);
    }
    
    .stats {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin: 30px 0;
    }
    
    .stat-box {
      background: #ecf0f1;
      padding: 18px 25px;
      border-radius: 12px;
      min-width: 170px;
      box-shadow: 0 6px 12px rgba(0,0,0,0.1);
      text-align: center;
    }
    
    .stat-value {
      font-size: 2.2rem;
      font-weight: bold;
      color: #3498db;
      margin-top: 10px;
    }
    
    .rules {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 25px;
      margin: 30px 0;
      box-shadow: 0 6px 12px rgba(0,0,0,0.05);
      border-left: 5px solid #3498db;
    }
    
    .rules h3 {
      color: #2c3e50;
      margin-bottom: 15px;
    }
    
    .rules-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
    }
    
    .rule-item {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
    }
    
    .rule-item h4 {
      color: #e74c3c;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    footer {
      margin-top: 30px;
      color: #7f8c8d;
      font-size: 1rem;
      text-align: center;
      padding-top: 20px;
      border-top: 1px solid #e0e0e0;
    }
    
    @media (max-width: 768px) {
      .container {
        padding: 15px;
      }
      
      .controls {
        flex-direction: column;
        align-items: center;
      }
      
      select, button {
        width: 100%;
        max-width: 300px;
      }
      
      .cell {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }
      
      .stats {
        flex-direction: column;
        align-items: center;
      }
      
      .stat-box {
        width: 100%;
      }
    }
    
    @media print {
      button, select, #helpModal, .stats, footer, .rules {
        display: none !important;
      }
      
      .container {
        box-shadow: none;
        padding: 0;
        background: white;
      }
      
      #kenkenGrid {
        box-shadow: none;
        margin-top: 0;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1><span>üß©</span> Generador de KenKen</h1>
      <p class="subtitle">Todos los grupos tienen al menos 2 celdas</p>
    </header>
    
    <div class="controls">
      <select id="gridSize">
        <option value="3">3√ó3 (F√°cil)</option>
        <option value="4">4√ó4 (F√°cil)</option>
        <option value="5">5√ó5 (Medio)</option>
        <option value="6" selected>6√ó6 (Medio)</option>
        <option value="7">7√ó7 (Dif√≠cil)</option>
        <option value="8">8√ó8 (Dif√≠cil)</option>
        <option value="9">9√ó9 (Experto)</option>
      </select>
      <button onclick="generateNewKenKen()">
        <span>üîÑ</span> Generar Nuevo KenKen
      </button>
      <button onclick="toggleSolutionDisplay()">
        <span>üëÅÔ∏è</span> Mostrar/Ocultar Soluci√≥n
      </button>
      <button onclick="window.print()">
        <span>üñ®Ô∏è</span> Imprimir/Exportar PDF
      </button>
      <button onclick="showHelp()">
        <span>‚ùì</span> C√≥mo Jugar
      </button>
    </div>
    
    <div class="stats">
      <div class="stat-box">
        <div>Tama√±o del Puzzle</div>
        <div class="stat-value" id="sizeStat">6√ó6</div>
      </div>
      <div class="stat-box">
        <div>Regiones Generadas</div>
        <div class="stat-value" id="regionsStat">0</div>
      </div>
      <div class="stat-box">
        <div>Tama√±o M√≠n. Regi√≥n</div>
        <div class="stat-value" id="minRegionStat">2</div>
      </div>
    </div>

    <div id="kenkenGrid"></div>
    
    <div class="rules">
      <h3>üìò Reglas del KenKen</h3>
      <div class="rules-list">
        <div class="rule-item">
          <h4><span>1Ô∏è‚É£</span> Sin n√∫meros repetidos</h4>
          <p>Los n√∫meros no deben repetirse en ninguna fila o columna.</p>
        </div>
        <div class="rule-item">
          <h4><span>üß©</span> Grupos con operaciones</h4>
          <p>Cada grupo tiene una operaci√≥n matem√°tica y un resultado que debe cumplirse.</p>
        </div>
        <div class="rule-item">
          <h4><span>üî¢</span> N√∫meros del 1 al N</h4>
          <p>Usa n√∫meros del 1 al tama√±o del puzzle (ej: 1-6 para un 6x6).</p>
        </div>
        <div class="rule-item">
          <h4><span>‚úÖ</span> Grupos de 2+ celdas</h4>
          <p>Todos los grupos tienen al menos 2 celdas. ¬°Sin grupos individuales!</p>
        </div>
      </div>
    </div>
    
    <footer>
      <p>KenKen es una marca registrada de Nextoy, LLC. Este generador es solo para uso educativo.</p>
    </footer>
  </div>

  <div id="helpModal" onclick="hideHelp()">
    <div id="helpContent" onclick="event.stopPropagation()">
      <h2>‚ùì ¬øC√≥mo jugar al KenKen?</h2>
      <p>KenKen es un puzzle matem√°tico que combina elementos del Sudoku con operaciones aritm√©ticas. El objetivo es llenar la cuadr√≠cula con n√∫meros siguiendo estas reglas:</p>
      
      <ul>
        <li><strong>Cada fila y columna</strong> debe contener n√∫meros √∫nicos del 1 al tama√±o del puzzle (sin repeticiones).</li>
        <li>La cuadr√≠cula est√° dividida en <strong>grupos</strong> (regiones delineadas) con una operaci√≥n matem√°tica (+, -, √ó, √∑) y un resultado.</li>
        <li>Los n√∫meros en cada grupo deben combinarse mediante la operaci√≥n indicada para producir el resultado objetivo.</li>
        <li><strong>¬°Importante!</strong> Todos los grupos tienen al menos 2 celdas - ¬°no hay grupos individuales!</li>
        <li>Para resta y divisi√≥n, el orden de los n√∫meros puede variar, pero el resultado debe ser un entero positivo.</li>
      </ul>
      
      <h3>üéØ Estrategias para resolver KenKen</h3>
      <ul>
        <li><strong>Comienza con grupos peque√±os</strong>: Los grupos de 2 celdas suelen tener menos combinaciones posibles.</li>
        <li><strong>Busca n√∫meros forzados</strong>: En grupos de suma o multiplicaci√≥n, identifica n√∫meros que solo pueden ir en ciertas celdas.</li>
        <li><strong>Usa las restricciones de fila/columna</strong>: Si un n√∫mero ya est√° en una fila o columna, no puede repetirse.</li>
        <li><strong>Considera m√∫ltiples operaciones</strong>: Para grupos grandes, piensa c√≥mo se combinan las operaciones.</li>
        <li><strong>Marca posibilidades</strong>: Usa l√°piz y papel para anotar n√∫meros posibles en cada celda.</li>
      </ul>
      
      <h3>üß© Ejemplo de grupo</h3>
      <p>Un grupo marcado como <strong>8√ó</strong> en un puzzle 6√ó6 podr√≠a contener:</p>
      <ul>
        <li>2 y 4 (2 √ó 4 = 8)</li>
        <li>1 y 8 (1 √ó 8 = 8)</li>
        <li>2, 2 y 2 (2 √ó 2 √ó 2 = 8) - pero solo si tiene 3 celdas</li>
      </ul>
      <p>Las posibilidades reales dependen de las restricciones de fila/columna.</p>
      
      <button onclick="hideHelp()">Cerrar</button>
    </div>
  </div>

  <script>
    function showHelp() {
      document.getElementById("helpModal").style.display = "flex";
    }

    function hideHelp() {
      document.getElementById("helpModal").style.display = "none";
    }

    let currentKenKen = null;
    let showAnswers = false;
    let attempts = 0;
    const MAX_ATTEMPTS = 100;

    // Difficulty mapping
    const DIFFICULTY_MAP = {
      3: "F√°cil",
      4: "F√°cil",
      5: "Medio",
      6: "Medio",
      7: "Dif√≠cil",
      8: "Dif√≠cil",
      9: "Experto"
    };

    function updateStats() {
      if (!currentKenKen) return;
      
      document.getElementById("sizeStat").textContent = `${currentKenKen.size}√ó${currentKenKen.size}`;
      document.getElementById("regionsStat").textContent = currentKenKen.regions.length;
      
      // Calculate min region size
      let minRegionSize = currentKenKen.size;
      currentKenKen.regions.forEach(region => {
        if (region.cells.length < minRegionSize) {
          minRegionSize = region.cells.length;
        }
      });
      document.getElementById("minRegionStat").textContent = minRegionSize;
    }

    function generateLatinSquare(size) {
      const grid = Array(size).fill(0).map(() => Array(size).fill(0));
      
      // Helper function to check if a number can be placed
      function isValid(r, c, num) {
        // Check row
        for (let x = 0; x < size; x++) {
          if (grid[r][x] === num) return false;
        }
        // Check column
        for (let x = 0; x < size; x++) {
          if (grid[x][c] === num) return false;
        }
        return true;
      }

      // Solve using backtracking
      function solve(r, c) {
        if (r === size) return true;
        
        const nextR = c === size - 1 ? r + 1 : r;
        const nextC = c === size - 1 ? 0 : c + 1;
        
        // Try numbers in random order
        const nums = Array.from({length: size}, (_, i) => i + 1);
        shuffleArray(nums);
        
        for (const num of nums) {
          if (isValid(r, c, num)) {
            grid[r][c] = num;
            if (solve(nextR, nextC)) return true;
            grid[r][c] = 0;
          }
        }
        return false;
      }
      
      // Start solving from top-left
      if (solve(0, 0)) {
        return grid;
      }
      return null;
    }
    
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function generateNewKenKen() {
      const size = parseInt(document.getElementById("gridSize").value);
      showAnswers = false;
      attempts = 0;
      
      // Generate a valid puzzle with retry logic
      let puzzle = null;
      while (!puzzle && attempts < MAX_ATTEMPTS) {
        puzzle = generateKenKenPuzzle(size);
        attempts++;
      }
      
      if (!puzzle) {
        alert("No se pudo generar un puzzle v√°lido. Int√©ntalo de nuevo.");
        return;
      }
      
      currentKenKen = puzzle;
      renderKenKenGrid();
      updateStats();
    }
    
    function generateKenKenPuzzle(size) {
      const solution = generateLatinSquare(size);
      if (!solution) return null;
      
      const regions = [];
      const usedCells = Array(size).fill(0).map(() => Array(size).fill(false));
      const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // Right, Down, Left, Up
      
      // Create a list of all cells
      const allCells = [];
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          allCells.push([r, c]);
        }
      }
      shuffleArray(allCells);
      
      // Create regions with at least 2 cells
      for (const [r, c] of allCells) {
        if (usedCells[r][c]) continue;
        
        const regionCells = [[r, c]];
        usedCells[r][c] = true;
        const queue = [[r, c]];
        
        // Target size between 2 and 4 (minimum 2)
        const maxRegionSize = Math.min(4, size);
        const targetSize = Math.floor(Math.random() * (maxRegionSize - 1)) + 2;
        
        while (regionCells.length < targetSize && queue.length > 0) {
          const [currR, currC] = queue.shift();
          
          // Shuffle directions for randomness
          shuffleArray(directions);
          
          for (const [dr, dc] of directions) {
            const newR = currR + dr;
            const newC = currC + dc;
            
            if (newR >= 0 && newR < size && newC >= 0 && newC < size && 
                !usedCells[newR][newC]) {
              regionCells.push([newR, newC]);
              usedCells[newR][newC] = true;
              queue.push([newR, newC]);
              
              if (regionCells.length >= targetSize) break;
            }
          }
        }
        
        // Only add regions with at least 2 cells
        if (regionCells.length >= 2) {
          regions.push({
            cells: regionCells,
          });
        }
      }
      
      // Assign operations and results
      for (const region of regions) {
        const nums = region.cells.map(([r, c]) => solution[r][c]);
        let op, result;
        
        // For regions with 2+ cells
        const operations = ['+', '√ó'];
        
        // For 2-cell regions, consider subtraction and division
        if (region.cells.length === 2) {
          const [a, b] = nums;
          
          // Check subtraction possibility
          if (Math.abs(a - b) > 0) {
            operations.push('-');
          }
          
          // Check division possibility (must be integer result)
          if ((a % b === 0 && a !== b) || (b % a === 0 && b !== a)) {
            operations.push('√∑');
          }
        }
        
        // Choose random operation
        op = operations[Math.floor(Math.random() * operations.length)];
        
        // Calculate result based on operation
        switch (op) {
          case '+':
            result = nums.reduce((sum, num) => sum + num, 0);
            break;
          case '√ó':
            result = nums.reduce((product, num) => product * num, 1);
            break;
          case '-':
            result = Math.abs(nums[0] - nums[1]);
            break;
          case '√∑':
            result = Math.max(nums[0], nums[1]) / Math.min(nums[0], nums[1]);
            break;
        }
        
        region.label = result + op;
        region.operation = op;
        region.target = result;
      }
      
      return { solution, regions, size };
    }

    function renderKenKenGrid() {
      if (!currentKenKen) return;
      
      const { solution, regions, size } = currentKenKen;
      const gridEl = document.getElementById("kenkenGrid");
      gridEl.innerHTML = '';
      gridEl.style.gridTemplateColumns = `repeat(${size}, 50px)`;
      gridEl.style.border = '4px solid #2c3e50';
      
      const cellElements = Array(size).fill(0).map(() => Array(size).fill(null));
      
      // Create cells
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          
          // Reset border classes
          cell.classList.remove(
            'border-top-region', 
            'border-right-region', 
            'border-bottom-region', 
            'border-left-region'
          );
          
          // Add solution number if showing answers
          if (showAnswers) {
            cell.textContent = solution[r][c];
          }
          
          gridEl.appendChild(cell);
          cellElements[r][c] = cell;
        }
      }
      
      // Add regions and borders
      regions.forEach(region => {
        const [firstR, firstC] = region.cells[0];
        const label = document.createElement('div');
        label.className = 'region-label';
        label.textContent = region.label;
        cellElements[firstR][firstC].appendChild(label);
        
        region.cells.forEach(([r, c]) => {
          const cell = cellElements[r][c];
          
          // Top border (if no same-region neighbor above)
          if (!region.cells.some(([nr, nc]) => nr === r-1 && nc === c)) {
            cell.classList.add('border-top-region');
          }
          
          // Right border
          if (!region.cells.some(([nr, nc]) => nr === r && nc === c+1)) {
            cell.classList.add('border-right-region');
          }
          
          // Bottom border
          if (!region.cells.some(([nr, nc]) => nr === r+1 && nc === c)) {
            cell.classList.add('border-bottom-region');
          }
          
          // Left border
          if (!region.cells.some(([nr, nc]) => nr === r && nc === c-1)) {
            cell.classList.add('border-left-region');
          }
        });
      });
    }

    function toggleSolutionDisplay() {
      showAnswers = !showAnswers;
      if (currentKenKen) renderKenKenGrid();
    }

    // Initialize on page load
    window.onload = () => {
      generateNewKenKen();
    };
  </script>
</body>
</html>