
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.5, user-scalable=yes">
  <title>Truth table ¬∑ SOP/POS + Logisim JSON export</title>
  <style>
    * { box-sizing: border-box; font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif; }
    body { background: #f1f5f9; min-height: 100vh; margin: 0; display: flex; justify-content: center; align-items: center; padding: 12px; }
    .card { background: white; max-width: 1200px; width: 100%; border-radius: 28px; box-shadow: 0 20px 35px -8px rgba(0,0,0,0.2); padding: 24px 20px 32px 20px; transition: all 0.2s; }
    h1 { font-size: 1.8rem; font-weight: 600; letter-spacing: -0.02em; margin: 0 0 10px 0; color: #0f172a; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    h1 small { font-size: 1rem; font-weight: 400; background: #e9eef3; color: #1e3a5f; padding: 4px 14px; border-radius: 40px; margin-left: 8px; white-space: nowrap; }
    .toolbar { display: flex; flex-wrap: wrap; gap: 14px; margin: 20px 0 25px 0; align-items: center; }
    .btn { background: white; border: 1px solid #cbd5e1; padding: 12px 26px; border-radius: 60px; font-size: 1.1rem; font-weight: 500; color: #1e293b; cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.02); transition: 0.15s; display: inline-flex; align-items: center; justify-content: center; gap: 8px; flex: 0 1 auto; -webkit-tap-highlight-color: transparent; }
    .btn-primary { background: #0f172a !important; border: 1px solid #0f172a !important; color: #ffffff !important; box-shadow: 0 4px 12px rgba(15, 23, 42, 0.3); opacity: 1 !important; }
    .btn-primary:hover { background: #1e293b !important; color: #ffffff !important; }
    .btn-primary:active { transform: scale(0.98); }
    .btn:active { transform: scale(0.96); background: #e9eef3; }
    .table-wrapper { overflow-x: auto; margin: 18px 0 28px 0; border-radius: 20px; border: 1px solid #dde3e9; background: #ffffff; box-shadow: 0 6px 12px rgba(0,0,0,0.04); }
    table { width: 100%; border-collapse: collapse; min-width: 380px; font-size: 1.1rem; }
    th { background: #f8fafc; font-weight: 600; color: #0b1e33; padding: 18px 10px; font-size: 1.2rem; border-bottom: 2px solid #b9c7d9; }
    td { text-align: center; padding: 16px 8px; border-bottom: 1px solid #dde3e9; font-weight: 500; }
    tr:last-child td { border-bottom: none; }
    .fixed-col { background-color: #f2f6fc; font-weight: 600; color: #022b54; }
    .f-cell { cursor: pointer; font-weight: 700; font-size: 1.3rem; transition: 0.1s; border-radius: 16px; user-select: none; -webkit-user-select: none; min-width: 75px; padding: 12px 8px; }
    .f-cell:active { transform: scale(0.95); }
    .f-cell[data-val="0"] { background-color: #ffffff; color: #0f172a; }
    .f-cell[data-val="0"]:hover { background-color: #f1f5f9; }
    .f-cell[data-val="1"] { background-color: #fff3e3; color: #d97706; }
    .f-cell[data-val="1"]:hover { background-color: #ffe0b9; }
    .f-cell[data-val="X"] { background-color: #e2e8f0; color: #64748b; font-style: italic; }
    .f-cell[data-val="X"]:hover { background-color: #cbd5e1; }
    .expr-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .expr-box { background: #f0f4fa; border-radius: 24px; padding: 22px 25px; margin: 8px 0; border-left: 6px solid #1e293b; }
    .expr-box.simp-sop { border-left-color: #10b981; background: #ecfdf5; }
    .expr-box.simp-pos { border-left-color: #8b5cf6; background: #f5f3ff; }
    .expr-title { font-weight: 600; font-size: 1.1rem; color: #0b2b44; margin-bottom: 12px; display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    .expr-output { background: #ffffffd6; padding: 16px 20px; border-radius: 20px; font-family: 'Courier New', Courier, monospace; font-size: 1.2rem; font-weight: 600; word-break: break-word; white-space: pre-wrap; line-height: 1.6; border: 1px solid #bacde0; box-shadow: inset 0 1px 5px #0000000d; }
    .d-care { color: #94a3b8; font-style: italic; }
    .footer-note { text-align: right; color: #526477; font-size: 0.9rem; margin-top: 16px; border-top: 1px dashed #bacde0; padding-top: 12px; }
    @media (max-width: 768px) { .expr-grid { grid-template-columns: 1fr; } }
    @media (max-width: 550px) { .card { padding: 18px 12px; } h1 { font-size: 1.5rem; } th { padding: 12px 5px; font-size: 1rem; } td { padding: 14px 4px; font-size: 1rem; } .f-cell { font-size: 1.2rem; min-width: 60px; } .btn { padding: 10px 18px; font-size: 1rem; } .expr-output { font-size: 1.1rem; padding: 14px 16px; } }
  </style>
</head>
<body>
<div class="card">
  <h1> ‚ö° 4‚Äëvariable truth table <small>a b c d fixed ¬∑ f toggles</small> </h1>
  <div class="toolbar">
    <button class="btn btn-primary" id="randomBtn">üé≤ Generate random f</button>
    <button class="btn" id="resetZeroBtn">‚è™ Set all f = 0</button>
    <!-- NEW BUTTON: download circuit as JSON (Logisim style) -->
    <button class="btn" id="downloadCircuitBtn">‚¨áÔ∏è Download circuit JSON (SOP)</button>
  </div>
  <div class="table-wrapper">
    <table id="truthTable">
      <thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th style="background:#e9eef3;">f</th></tr></thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
  <div class="expr-grid">
    <div class="expr-box"><div class="expr-title">üîπ Canonical SOP (Minterms)</div><div class="expr-output" id="sopExpr">‚Äî</div></div>
    <div class="expr-box"><div class="expr-title">üî∏ Canonical POS (Maxterms)</div><div class="expr-output" id="posExpr">‚Äî</div></div>
    <div class="expr-box simp-sop"><div class="expr-title">‚ú® Simplified SOP</div><div class="expr-output" id="simpsopExpr">‚Äî</div></div>
    <div class="expr-box simp-pos"><div class="expr-title">‚ú® Simplified POS</div><div class="expr-output" id="simpposExpr">‚Äî</div></div>
  </div>
  <div class="footer-note">‚ö° click any f cell to cycle: 0 ‚Üí 1 ‚Üí X (Don't Care)</div>
</div>

<script>
(function() {
  const rows = 16;
  const varNames = ['a', 'b', 'c', 'd'];
  let fValues = new Array(rows).fill(0);

  const tbody = document.getElementById('tableBody');
  const sopSpan = document.getElementById('sopExpr');
  const posSpan = document.getElementById('posExpr');
  const simpsopSpan = document.getElementById('simpsopExpr');
  const simpposSpan = document.getElementById('simpposExpr');
  const randomBtn = document.getElementById('randomBtn');
  const resetZeroBtn = document.getElementById('resetZeroBtn');
  const downloadBtn = document.getElementById('downloadCircuitBtn');

  // Global variables to store current simplified terms (for export)
  window.currentSimpSOP = [];
  window.currentSimpPOS = [];

  function randomF() {
    for (let i = 0; i < rows; i++) {
      const r = Math.random();
      if (r < 0.4) fValues[i] = 0;
      else if (r < 0.8) fValues[i] = 1;
      else fValues[i] = 'X';
    }
  }

  function renderTable() {
    let html = '';
    for (let i = 0; i < rows; i++) {
      const a = (i >> 3) & 1, b = (i >> 2) & 1, c = (i >> 1) & 1, d = i & 1;
      html += `<tr>
        <td class="fixed-col">${a}</td>
        <td class="fixed-col">${b}</td>
        <td class="fixed-col">${c}</td>
        <td class="fixed-col">${d}</td>
        <td class="f-cell" data-index="${i}" data-val="${fValues[i]}">${fValues[i]}</td>
      </tr>`;
    }
    tbody.innerHTML = html;
    document.querySelectorAll('.f-cell').forEach(cell => {
      cell.addEventListener('click', function() {
        const index = parseInt(this.getAttribute('data-index'), 10);
        const current = fValues[index];
        if (current === 0) fValues[index] = 1;
        else if (current === 1) fValues[index] = 'X';
        else fValues[index] = 0;
        renderTable();
        updateExpressions();
      });
    });
  }

  // ---------- Quine‚ÄëMcCluskey style simplification (same as original, but returns terms) ----------
  function covers(pi, minterm) {
    for (let i = 0; i < 4; i++) {
      if (pi[i] !== '-' && pi[i] !== minterm[i]) return false;
    }
    return true;
  }

  function simplifyLogic(targetTerms, allowedTerms) {
    if (targetTerms.length === 0) return [];
    if (allowedTerms.length === 16 && targetTerms.length > 0) return ['----'];
    let combined = new Set(allowedTerms.map(m => m.toString(2).padStart(4, '0')));
    let pis = new Set();
    let hasMerged = true;
    while (hasMerged) {
      hasMerged = false;
      let nextCombined = new Set();
      let used = new Set();
      let arr = Array.from(combined);
      for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
          let diff = 0, idx = -1;
          for (let k = 0; k < 4; k++) {
            if (arr[i][k] !== arr[j][k]) {
              diff++;
              idx = k;
            }
          }
          if (diff === 1) {
            nextCombined.add(arr[i].substring(0, idx) + '-' + arr[i].substring(idx + 1));
            used.add(arr[i]);
            used.add(arr[j]);
            hasMerged = true;
          }
        }
      }
      for (let t of arr) if (!used.has(t)) pis.add(t);
      combined = nextCombined;
    }
    let piArray = Array.from(pis);
    let remaining = new Set(targetTerms.map(m => m.toString(2).padStart(4, '0')));
    let selected = [];
    let mToPI = {};
    for (let m of remaining) {
      mToPI[m] = piArray.filter(pi => covers(pi, m));
    }
    for (let m in mToPI) {
      if (mToPI[m].length === 1) {
        let epi = mToPI[m][0];
        if (!selected.includes(epi)) {
          selected.push(epi);
          for (let rm of Array.from(remaining)) {
            if (covers(epi, rm)) remaining.delete(rm);
          }
        }
      }
    }
    while (remaining.size > 0) {
      let best = null, maxCount = -1;
      for (let pi of piArray) {
        if (selected.includes(pi)) continue;
        let count = 0;
        for (let rm of remaining) if (covers(pi, rm)) count++;
        if (count > maxCount) {
          maxCount = count;
          best = pi;
        }
      }
      if (best) {
        selected.push(best);
        for (let rm of Array.from(remaining)) {
          if (covers(best, rm)) remaining.delete(rm);
        }
      } else break;
    }
    return selected;
  }

  function updateExpressions() {
    let ones = [], zeros = [], dcares = [];
    for (let i = 0; i < rows; i++) {
      if (fValues[i] === 1) ones.push(i);
      else if (fValues[i] === 0) zeros.push(i);
      else dcares.push(i);
    }

    // canonical SOP
    let sopTerms = ones.map(m => (m&8?'a':'a\'') + (m&4?'b':'b\'') + (m&2?'c':'c\'') + (m&1?'d':'d\''));
    let sopDcares = dcares.map(m => `<span class="d-care">${(m&8?'a':'a\'') + (m&4?'b':'b\'') + (m&2?'c':'c\'') + (m&1?'d':'d\'')}</span>`);
    let allSop = sopTerms.concat(sopDcares);
    sopSpan.innerHTML = allSop.length ? allSop.join(' + ') : '0';

    // canonical POS
    let posTerms = zeros.map(m => `(${(m&8?'a\'':'a')} + ${(m&4?'b\'':'b')} + ${(m&2?'c\'':'c')} + ${(m&1?'d\'':'d')})`);
    let posDcares = dcares.map(m => `<span class="d-care">(${(m&8?'a\'':'a')} + ${(m&4?'b\'':'b')} + ${(m&2?'c\'':'c')} + ${(m&1?'d\'':'d')})</span>`);
    let allPos = posTerms.concat(posDcares);
    posSpan.innerHTML = allPos.length ? allPos.join(' ¬∑ ') : '1';

    // simplified SOP (store terms globally)
    let simpsopPIs = simplifyLogic(ones, ones.concat(dcares));
    window.currentSimpSOP = simpsopPIs;   // for export
    if (simpsopPIs.length === 0) simpsopSpan.innerText = '0';
    else if (simpsopPIs.includes('----')) simpsopSpan.innerText = '1';
    else {
      simpsopSpan.innerText = simpsopPIs.map(pi => {
        let term = '';
        for (let i = 0; i < 4; i++) {
          if (pi[i] === '1') term += varNames[i];
          else if (pi[i] === '0') term += varNames[i] + "'";
        }
        return term;
      }).join(' + ');
    }

    // simplified POS (store)
    let simpposPIs = simplifyLogic(zeros, zeros.concat(dcares));
    window.currentSimpPOS = simpposPIs;
    if (simpposPIs.length === 0) simpposSpan.innerText = '1';
    else if (simpposPIs.includes('----')) simpposSpan.innerText = '0';
    else {
      simpposSpan.innerText = simpposPIs.map(pi => {
        let vars = [];
        for (let i = 0; i < 4; i++) {
          if (pi[i] === '0') vars.push(varNames[i]);
          else if (pi[i] === '1') vars.push(varNames[i] + "'");
        }
        return '(' + vars.join(' + ') + ')';
      }).join(' ¬∑ ');
    }
  }

  // ---------- new: generate Logisim-style JSON from simplified SOP terms ----------
  function generateCircuitFromSOP(terms) {
    // terms is array like ["01-0", "1--1"] or empty or ["----"]
    let components = [];
    let connections = [];
    let nextId = 0;

    // helper to add a component and return its id
    function addComp(type, x, y, value = 0, label = '') {
      let id = nextId++;
      components.push({ id, type, x, y, value, label });
      return id;
    }

    // constant cases
    if (terms.length === 0) {
      // output 0
      let inputId = addComp('INPUT', 60, 200, 0);
      let outId = addComp('OUTPUT', 620, 200);
      connections.push({ from: { id: inputId, port: 'out' }, to: { id: outId, port: 'in' } });
      return { components, connections };
    }
    if (terms.includes('----')) {
      // output 1
      let inputId = addComp('INPUT', 60, 200, 1);
      let outId = addComp('OUTPUT', 620, 200);
      connections.push({ from: { id: inputId, port: 'out' }, to: { id: outId, port: 'in' } });
      return { components, connections };
    }

    // --- create fixed INPUTs for a,b,c,d (x=60) ---
    let inputY = [100, 180, 260, 340];
    let inputIds = [];
    for (let i = 0; i < 4; i++) {
      inputIds.push(addComp('INPUT', 60, inputY[i], 0)); // value will be overwritten by simulation, but we set 0
    }

    // determine which variables need a NOT gate (bit 0 in any term)
    let needNot = [false, false, false, false];
    for (let t of terms) {
      for (let i = 0; i < 4; i++) {
        if (t[i] === '0') needNot[i] = true;
      }
    }
    // create NOT gates at x=140, spaced evenly
    let notIds = [null, null, null, null];
    let notIndex = 0;
    let notYStart = 120;
    for (let i = 0; i < 4; i++) {
      if (needNot[i]) {
        let y = notYStart + notIndex * 80;
        notIds[i] = addComp('NOT', 140, y, 0);
        // connect from corresponding INPUT
        connections.push({ from: { id: inputIds[i], port: 'out' }, to: { id: notIds[i], port: 'in' } });
        notIndex++;
      }
    }

    // prepare to build AND gates for each term (x=260)
    let termOutputs = []; // array of {id, port} for each product term
    let andY = 100;       // dynamic y for AND gates (increment after each)

    for (let t of terms) {
      // collect source wires for this term (literals)
      let sources = [];
      for (let i = 0; i < 4; i++) {
        if (t[i] === '1') {
          sources.push({ id: inputIds[i], port: 'out' });
        } else if (t[i] === '0') {
          // must have NOT gate
          if (notIds[i] === null) {
            console.warn('missing NOT for var', i);
            continue;
          }
          sources.push({ id: notIds[i], port: 'out' });
        }
      }
      if (sources.length === 0) continue; // should not happen

      // build AND chain for this term
      if (sources.length === 1) {
        termOutputs.push(sources[0]);
      } else {
        let current = sources[0];
        for (let j = 1; j < sources.length; j++) {
          let andId = addComp('AND', 260, andY, 0);
          andY += 60; // increment for next AND
          // connect current and sources[j] to this AND
          connections.push({ from: current, to: { id: andId, port: 'in1' } });
          connections.push({ from: sources[j], to: { id: andId, port: 'in2' } });
          current = { id: andId, port: 'out' };
        }
        termOutputs.push(current);
      }
    }

    // combine term outputs with OR gates (x=380 for first level, last at maybe x=500 if many)
    if (termOutputs.length === 1) {
      // single term, direct to output
      let outId = addComp('OUTPUT', 620, 200);
      connections.push({ from: termOutputs[0], to: { id: outId, port: 'in' } });
    } else {
      // build OR chain (all at x=380 for simplicity, but we can shift last a bit)
      let orY = 120;
      let currentOr = termOutputs[0];
      for (let j = 1; j < termOutputs.length; j++) {
        let orId = addComp('OR', 380, orY, 0);
        orY += 70;
        connections.push({ from: currentOr, to: { id: orId, port: 'in1' } });
        connections.push({ from: termOutputs[j], to: { id: orId, port: 'in2' } });
        currentOr = { id: orId, port: 'out' };
      }
      // final output
      let outId = addComp('OUTPUT', 620, orY - 35, 0); // center roughly
      connections.push({ from: currentOr, to: { id: outId, port: 'in' } });
    }

    return { components, connections };
  }

  // download JSON
  downloadBtn.addEventListener('click', function() {
    let circuit = generateCircuitFromSOP(window.currentSimpSOP || []);
    let jsonStr = JSON.stringify(circuit, null, 2);
    let blob = new Blob([jsonStr], { type: 'application/json' });
    let url = URL.createObjectURL(blob);
    let a = document.createElement('a');
    a.href = url;
    a.download = 'circuit.json';
    a.click();
    URL.revokeObjectURL(url);
  });

  // initialisation
  function init() {
    renderTable();
    updateExpressions();
    randomBtn.addEventListener('click', function() {
      randomF();
      renderTable();
      updateExpressions();
    });
    resetZeroBtn.addEventListener('click', function() {
      fValues.fill(0);
      renderTable();
      updateExpressions();
    });
  }
  init();
})();
</script>
</body>
</html>

