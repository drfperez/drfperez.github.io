
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MiniSim ¬∑ Logic Gate Lab</title>
    <style>
        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        body {
            background: #dfe6e9;
            margin: 20px;
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
        }
        .main-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 20px;
            background: #2c3e50;
            color: white;
            padding: 12px 24px;
            border-radius: 60px;
            box-shadow: 0 8px 12px rgba(0,0,0,0.2);
        }
        .main-header h1 {
            margin: 0;
            font-size: 2.2rem;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        .help-btn {
            background: #ecf0f1;
            border: none;
            color: #2c3e50;
            font-size: 1.8rem;
            font-weight: bold;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: 0.2s;
            margin-left: auto;
        }
        .help-btn:hover { background: #bdc3c7; transform: scale(1.05); }
        .help-btn:active { transform: scale(0.95); }
        .spec-panel {
            background: white;
            border-radius: 28px;
            box-shadow: 0 20px 35px -8px rgba(0,0,0,0.2);
            padding: 24px 20px 32px 20px;
            margin-bottom: 30px;
            border: 1px solid #b0c4d9;
        }
        .spec-panel h2 {
            font-size: 1.6rem;
            font-weight: 600;
            margin: 0 0 10px 0;
            color: #0f172a;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .spec-panel h2 small {
            font-size: 1rem;
            font-weight: 400;
            background: #e9eef3;
            color: #1e3a5f;
            padding: 4px 14px;
            border-radius: 40px;
        }
        .spec-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 14px;
            margin: 20px 0 25px 0;
            align-items: center;
        }
        .btn {
            background: white;
            border: 1px solid #cbd5e1;
            padding: 12px 26px;
            border-radius: 60px;
            font-size: 1.1rem;
            font-weight: 500;
            color: #1e293b;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.02);
            transition: 0.15s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn-primary {
            background: #0f172a !important;
            border: 1px solid #0f172a !important;
            color: #ffffff !important;
            box-shadow: 0 4px 12px rgba(15, 23, 42, 0.3);
        }
        .btn-primary:hover { background: #1e293b !important; }
        .btn:active { transform: scale(0.96); background: #e9eef3; }
        .table-wrapper {
            overflow-x: auto;
            margin: 18px 0 28px 0;
            border-radius: 20px;
            border: 1px solid #dde3e9;
            background: #ffffff;
            box-shadow: 0 6px 12px rgba(0,0,0,0.04);
        }
        .spec-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 380px;
            font-size: 1.1rem;
        }
        .spec-table th {
            background: #f8fafc;
            font-weight: 600;
            color: #0b1e33;
            padding: 18px 10px;
            font-size: 1.2rem;
            border-bottom: 2px solid #b9c7d9;
        }
        .spec-table td {
            text-align: center;
            padding: 16px 8px;
            border-bottom: 1px solid #dde3e9;
            font-weight: 500;
        }
        .spec-table .fixed-col {
            background-color: #f2f6fc;
            font-weight: 600;
            color: #022b54;
        }
        .f-cell {
            cursor: pointer;
            font-weight: 700;
            font-size: 1.3rem;
            transition: 0.1s;
            border-radius: 16px;
            user-select: none;
            min-width: 75px;
            padding: 12px 8px;
            touch-action: manipulation;
        }
        .f-cell[data-val="0"] { background-color: #ffffff; color: #0f172a; }
        .f-cell[data-val="0"]:hover { background-color: #f1f5f9; }
        .f-cell[data-val="1"] { background-color: #fff3e3; color: #d97706; }
        .f-cell[data-val="1"]:hover { background-color: #ffe0b9; }
        .f-cell[data-val="X"] { background-color: #e2e8f0; color: #64748b; font-style: italic; }
        .f-cell[data-val="X"]:hover { background-color: #cbd5e1; }
        .kmap-wrapper {
            background: white;
            border-radius: 24px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            padding: 24px;
            margin: 25px 0 30px 0;
        }
        .kmap-title {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.45rem;
            color: #1e293b;
            font-weight: 600;
        }
        .kmap-table {
            border-collapse: collapse;
            margin: 0 auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        .kmap-table th, .kmap-table td {
            width: 58px;
            height: 58px;
            text-align: center;
            vertical-align: middle;
            font-size: 1.45rem;
            border: 3px solid #e2e8f0;
            transition: all 0.2s;
        }
        .kmap-table th {
            background: #f1f5f9;
            font-weight: 700;
            color: #475569;
            font-size: 1rem;
        }
        .kmap-cell {
            cursor: pointer;
            font-weight: 700;
            touch-action: manipulation;
        }
        .kmap-cell[data-val="0"] { background: #f8fafc; color: #334155; }
        .kmap-cell[data-val="1"] { background: #fefce8; color: #ca8a04; }
        .kmap-cell[data-val="X"] { background: #ecfeff; color: #0e7490; font-style: italic; }
        .kmap-cell:hover { transform: scale(1.15); box-shadow: 0 0 0 4px #3b82f6 inset; }
        .expr-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }
        .expr-box {
            background: #f0f4fa;
            border-radius: 24px;
            padding: 22px 25px;
            margin: 8px 0;
            border-left: 6px solid #1e293b;
        }
        .expr-box.simp-sop { border-left-color: #10b981; background: #ecfdf5; }
        .expr-box.simp-pos { border-left-color: #8b5cf6; background: #f5f3ff; }
        .expr-title {
            font-weight: 600;
            font-size: 1.1rem;
            color: #0b2b44;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .expr-output {
            background: #ffffffd6;
            padding: 16px 20px;
            border-radius: 20px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.2rem;
            font-weight: 600;
            word-break: break-word;
            white-space: pre-wrap;
            line-height: 1.6;
            border: 1px solid #bacde0;
            box-shadow: inset 0 1px 5px #0000000d;
        }
        .d-care { color: #94a3b8; font-style: italic; }
        #canvas {
            border: 3px solid #2c3e50;
            background-color: #f1f3f5;
            width: 100%;
            height: auto;
            display: block;
            border-radius: 20px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            touch-action: none;
            margin-top: 20px;
        }
        .draggable { cursor: grab; touch-action: none; }
        .draggable:active { cursor: grabbing; }
        #toolbar {
            margin-bottom: 16px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            background: #e9ecef;
            padding: 16px 20px;
            border-radius: 40px;
            align-items: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        button {
            padding: 10px 18px;
            border: none;
            background: #3498db;
            color: white;
            font-weight: 600;
            border-radius: 40px;
            cursor: pointer;
            transition: 0.15s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            min-width: 70px;
            font-size: 1rem;
            border: 1px solid rgba(255,255,255,0.3);
            touch-action: manipulation;
        }
        button:active { transform: scale(0.96); background: #2980b9; }
        button.wire-active { background: #e67e22; box-shadow: 0 0 0 3px #f39c12; }
        button.sim-active { background: #27ae60; box-shadow: 0 0 0 3px #2ecc71; }
        .status-text {
            margin-left: auto;
            font-family: 'Fira Mono', monospace;
            font-weight: 600;
            color: #1e272e;
            background: white;
            padding: 8px 20px;
            border-radius: 40px;
            box-shadow: inset 0 1px 4px rgba(0,0,0,0.2);
            font-size: 0.95rem;
        }
        #helpModal {
            display: none;
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #2c3e50;
            border-radius: 24px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.4);
            z-index: 2000;
            max-width: 90vw;
            max-height: 85vh;
            overflow: auto;
        }
        #closeHelp { float: right; cursor: pointer; font-size: 28px; font-weight: bold; margin-left: 20px; }
        .overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1999;
        }
        @media (max-width: 768px) {
            .expr-grid { grid-template-columns: 1fr; }
            .btn { padding: 8px 16px; font-size: 1rem; }
            .main-header h1 { font-size: 1.8rem; }
        }
    </style>
</head>
<body>
<div class="main-header">
    <h1>‚ö° MiniSim</h1>
    <button class="help-btn" id="helpButton">?</button>
</div>
<div class="spec-panel">
    <h2>‚ö° 4‚Äëvariable truth table <small>a b c d fixed ¬∑ f toggles (0/1/X)</small></h2>
    <div class="spec-toolbar">
        <button class="btn btn-primary" id="randomSpecBtn">üé≤ Random f</button>
        <button class="btn" id="resetSpecBtn">‚è™ All f = 0</button>
        <button class="btn" id="buildCircuitBtn">‚öôÔ∏è Build from SOP</button>
    </div>
    <div class="table-wrapper">
        <table class="spec-table" id="specTable">
            <thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th style="background:#e9eef3;">f</th></tr></thead>
            <tbody id="specTableBody"></tbody>
        </table>
    </div>
    <div class="kmap-wrapper">
        <div class="kmap-title">üìä Interactive Karnaugh Map (ab ‚Üì  cd ‚Üí)</div>
        <table class="kmap-table" id="kmapTable">
            <thead><tr><th></th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead>
            <tbody id="kmapBody"></tbody>
        </table>
        <div style="text-align:center; margin-top:12px; color:#64748b; font-size:0.95rem;">
            üëÜ Click any cell to cycle 0 ‚Üí 1 ‚Üí X ‚Ä¢ Live sync with truth table
        </div>
    </div>
    <div class="expr-grid">
        <div class="expr-box"><div class="expr-title">üîπ Canonical SOP (Minterms)</div><div class="expr-output" id="sopExpr">‚Äî</div></div>
        <div class="expr-box"><div class="expr-title">üî∏ Canonical POS (Maxterms)</div><div class="expr-output" id="posExpr">‚Äî</div></div>
        <div class="expr-box simp-sop"><div class="expr-title">‚ú® Simplified SOP</div><div class="expr-output" id="simpsopExpr">‚Äî</div></div>
        <div class="expr-box simp-pos"><div class="expr-title">‚ú® Simplified POS</div><div class="expr-output" id="simpposExpr">‚Äî</div></div>
    </div>
    <div style="text-align:right; color:#526477; font-size:0.9rem; margin-top:10px;">‚ö° click any f or K-map cell to cycle: 0 ‚Üí 1 ‚Üí X</div>
</div>
<div id="toolbar">
    <button onclick="addGate('AND')">‚ûï AND</button>
    <button onclick="addGate('OR')">‚ûï OR</button>
    <button onclick="addGate('NOT')">‚ûï NOT</button>
    <button onclick="addInput()">üîò Input</button>
    <button onclick="addOutput()">üñçÔ∏è Output</button>
    <button id="wireBtn" onclick="toggleWireMode()">üîå Wire</button>
    <button id="simBtn" onclick="toggleSimulate()">‚ñ∂ Simulate</button>
    <button onclick="saveCircuit()">üíæ Save</button>
    <button onclick="loadCircuit()">üìÇ Load</button>
    <button onclick="undo()">‚Ü©Ô∏è Undo</button>
    <button onclick="redo()">‚Ü™Ô∏è Redo</button>
    <span class="status-text" id="status">‚ö° ready</span>
</div>
<svg id="canvas" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet"></svg>
<div id="helpModal">
    <span id="closeHelp" onclick="closeHelpModal()">&times;</span>
    <h3>How to use MiniSim ‚Äì Simplified Edition</h3>
    <p><strong>1. Define your function</strong><br>Click cells in the truth table or Karnaugh Map to set f = 0 / 1 / X. Expressions update instantly.</p>
    <p><strong>2. Karnaugh Map</strong><br>Visual tool for simplification ‚Äì click cells, watch SOP and POS change live.</p>
    <p><strong>3. Build circuit</strong><br>Click ‚ÄúBuild from SOP‚Äù ‚Äì automatically creates a clean two‚Äëlevel circuit from the simplified SOP expression.</p>
    <p><strong>4. Simulate &amp; edit</strong><br>Add gates, wire (output ‚Üí input), toggle simulation. Right‚Äëclick any component to delete.</p>
    <p><strong>5. Save / Load</strong><br>Use the toolbar buttons to save your circuit to a JSON file or load a previously saved one. Undo/Redo works on both circuit and truth table.</p>
    <p style="margin-top:25px; font-style:italic; color:#475569;">Perfect for learning Boolean algebra, K‚Äëmaps, and gate‚Äëlevel design. Enjoy!</p>
</div>
<div id="helpOverlay" class="overlay" onclick="closeHelpModal()"></div>

<script>
(function() {
    const svgNS = "http://www.w3.org/2000/svg";
    let components = [];
    let connections = [];
    let nextId = 0;
    let wiring = false;
    let startPoint = null;
    let simulating = false;

    const svg = document.getElementById('canvas');
    const wireBtn = document.getElementById('wireBtn');
    const simBtn = document.getElementById('simBtn');
    const statusSpan = document.getElementById('status');

    let historyStack = [];
    let historyIndex = -1;
    const MAX_HISTORY = 60;

    const specRows = 16;
    const specVarNames = ['a', 'b', 'c', 'd'];
    let specFValues = new Array(specRows).fill(0);
    const specTbody = document.getElementById('specTableBody');
    const sopSpan = document.getElementById('sopExpr');
    const posSpan = document.getElementById('posExpr');
    const simpsopSpan = document.getElementById('simpsopExpr');
    const simpposSpan = document.getElementById('simpposExpr');
    window.currentSimpSOP = [];

    const kmapBody = document.getElementById('kmapBody');
    const kmapGray = [0, 1, 3, 2];

    function getTranslateFromElement(el) {
        let trans = el.getAttribute('transform');
        if (!trans) return { x: 0, y: 0 };
        let match = trans.match(/translate\(\s*([-\d.]+)[,\s]+([-\d.]+)\s*\)/);
        if (match) return { x: parseFloat(match[1]), y: parseFloat(match[2]) };
        return { x: 0, y: 0 };
    }

    function getPointPos(compId, port) {
        const g = svg.querySelector(`g[data-id="${compId}"]`);
        if (!g) return { x: 0, y: 0 };
        const c = g.querySelector(`circle[data-port="${port}"]`);
        if (!c) return { x: 0, y: 0 };
        const trans = getTranslateFromElement(g);
        const cx = parseFloat(c.getAttribute('cx'));
        const cy = parseFloat(c.getAttribute('cy'));
        return { x: trans.x + cx, y: trans.y + cy };
    }

    function updateWiresForComp(id) {
        connections.forEach(conn => {
            if (conn.from.id === id || conn.to.id === id) {
                const start = getPointPos(conn.from.id, conn.from.port);
                const end = getPointPos(conn.to.id, conn.to.port);
                conn.line.setAttribute('x1', start.x);
                conn.line.setAttribute('y1', start.y);
                conn.line.setAttribute('x2', end.x);
                conn.line.setAttribute('y2', end.y);
            }
        });
    }

    function getValue(id, visited = new Set()) {
        if (visited.has(id)) return 0;
        visited.add(id);
        let comp = components.find(c => c.id == id);
        if (!comp) return 0;
        if (comp.value !== undefined) return comp.value;
        let inVals = {};
        for (let port in comp.connectionsIn) {
            let from = comp.connectionsIn[port];
            inVals[port] = getValue(from.fromId, visited);
        }
        if (comp.type === 'AND') comp.value = (inVals['in1'] && inVals['in2']) ? 1 : 0;
        else if (comp.type === 'OR') comp.value = (inVals['in1'] || inVals['in2']) ? 1 : 0;
        else if (comp.type === 'NOT') comp.value = (inVals['in'] ? 0 : 1);
        else if (comp.type === 'OUTPUT') comp.value = inVals['in'] || 0;
        else comp.value = 0;
        return comp.value;
    }

    function propagate() {
        if (!simulating) return;
        components.forEach(c => { if (c.type !== 'INPUT') c.value = undefined; });
        components.forEach(c => { c.value = getValue(c.id, new Set()); });
        components.filter(c => c.type === 'OUTPUT').forEach(out => {
            let g = svg.querySelector(`g[data-id="${out.id}"]`);
            if (g) {
                let text = g.querySelector('text.valueText');
                if (text) {
                    text.textContent = out.value;
                    text.setAttribute('fill', out.value ? '#27ae60' : '#e74c3c');
                }
            }
        });
        components.filter(c => c.type === 'INPUT').forEach(inp => {
            let g = svg.querySelector(`g[data-id="${inp.id}"]`);
            if (g) {
                let text = g.querySelector('text.valueText');
                if (text) {
                    text.textContent = inp.value;
                    text.setAttribute('fill', inp.value ? '#27ae60' : '#e74c3c');
                }
            }
        });
        connections.forEach(conn => {
            let sourceVal = getValue(conn.from.id, new Set());
            conn.line.setAttribute('stroke', sourceVal ? '#27ae60' : '#e74c3c');
        });
    }

    function toggleWireMode() {
        wiring = !wiring;
        startPoint = null;
        wireBtn.textContent = wiring ? '‚õî Stop Wire' : 'üîå Wire';
        wireBtn.classList.toggle('wire-active', wiring);
        updateStatus();
    }

    function toggleSimulate() {
        simulating = !simulating;
        simBtn.textContent = simulating ? '‚èπÔ∏è Stop Sim' : '‚ñ∂ Simulate';
        simBtn.classList.toggle('sim-active', simulating);
        updateStatus();
        if (simulating) propagate();
        else {
            connections.forEach(conn => conn.line.setAttribute('stroke', '#2c3e50'));
            components.forEach(c => {
                let g = svg.querySelector(`g[data-id="${c.id}"]`);
                if (g) {
                    let rect = g.querySelector('rect');
                    if (rect) rect.setAttribute('stroke', '#2c3e50');
                }
            });
        }
    }

    function handlePointClick(e) {
        if (!wiring) return;
        e.stopPropagation();
        let point = e.target;
        let g = point.closest('g');
        if (!g) return;
        let id = g.dataset.id;
        let port = point.dataset.port;
        let pos = getPointPos(id, port);
        if (startPoint === null) {
            if (!point.classList.contains('output')) { alert('Wire must start from an OUTPUT port.'); return; }
            startPoint = { id, port, pos };
            statusSpan.innerHTML = `üìç from ${g.querySelector('text.labelText')?.textContent || '?'} ‚Ä¢ ${port}`;
        } else {
            if (!point.classList.contains('input')) { alert('Wire must end at an INPUT port.'); return; }
            if (startPoint.id === id) { alert('Cannot connect to same component.'); return; }
            let targetComp = components.find(c => c.id == id);
            if (targetComp.connectionsIn && targetComp.connectionsIn[port]) {
                let oldIndex = connections.findIndex(c => c.to.id == id && c.to.port == port);
                if (oldIndex !== -1) {
                    connections[oldIndex].line.remove();
                    connections.splice(oldIndex, 1);
                }
                delete targetComp.connectionsIn[port];
            }
            let line = document.createElementNS(svgNS, 'line');
            line.setAttribute('stroke', '#2c3e50');
            line.setAttribute('stroke-width', '2.5');
            line.setAttribute('x1', startPoint.pos.x);
            line.setAttribute('y1', startPoint.pos.y);
            line.setAttribute('x2', pos.x);
            line.setAttribute('y2', pos.y);
            svg.insertBefore(line, svg.firstChild);
            connections.push({ from: { id: startPoint.id, port: startPoint.port }, to: { id, port }, line });
            if (!targetComp.connectionsIn) targetComp.connectionsIn = {};
            targetComp.connectionsIn[port] = { fromId: startPoint.id, fromPort: startPoint.port };
            startPoint = null;
            updateStatus();
            pushState();
        }
    }

    svg.addEventListener('click', (e) => {
        if (e.target === svg && wiring && startPoint) { startPoint = null; updateStatus(); }
    });

    function toggleInput(e) {
        if (!simulating) return;
        let g = e.currentTarget;
        let id = g.dataset.id;
        let comp = components.find(c => c.id == id);
        comp.value = 1 - comp.value;
        let text = g.querySelector('text.valueText');
        if (text) {
            text.textContent = comp.value;
            text.setAttribute('fill', comp.value ? '#27ae60' : '#e74c3c');
        }
        propagate();
    }

    function editLabel(e) {
        e.stopPropagation();
        let g = e.currentTarget;
        let id = g.dataset.id;
        let comp = components.find(c => c.id == id);
        if (!comp) return;
        let newLabel = prompt('New label:', comp.label || '');
        if (newLabel !== null) {
            comp.label = newLabel;
            let labelText = g.querySelector('text.labelText');
            if (labelText) labelText.textContent = newLabel;
            pushState();
        }
    }

    function deleteComponent(id) {
        connections = connections.filter(conn => {
            if (conn.from.id == id || conn.to.id == id) {
                if (conn.line && conn.line.parentNode) conn.line.remove();
                return false;
            }
            return true;
        });
        const idx = components.findIndex(c => c.id == id);
        if (idx !== -1) {
            const g = svg.querySelector(`g[data-id="${id}"]`);
            if (g) g.remove();
            components.splice(idx, 1);
        }
        pushState();
        if (simulating) propagate();
    }

    function addDeleteListener(g) {
        g.addEventListener('contextmenu', e => {
            e.preventDefault();
            const id = parseInt(g.dataset.id);
            const comp = components.find(c => c.id == id);
            if (confirm(`Delete this ${comp ? comp.type : 'component'}?`)) {
                deleteComponent(id);
            }
        });
    }

    function createRect(x, y, w, h, fill = '#f5f7fa', stroke = '#2c3e50') {
        let r = document.createElementNS(svgNS, 'rect');
        r.setAttribute('x', x); r.setAttribute('y', y); r.setAttribute('width', w); r.setAttribute('height', h);
        r.setAttribute('fill', fill); r.setAttribute('stroke', stroke); r.setAttribute('stroke-width', '1.8');
        r.setAttribute('rx', '6'); r.setAttribute('ry', '6');
        return r;
    }
    function createText(x, y, t, size = '16', color = '#1e272e', cls = '') {
        let txt = document.createElementNS(svgNS, 'text');
        txt.setAttribute('x', x); txt.setAttribute('y', y); txt.setAttribute('font-size', size);
        txt.setAttribute('text-anchor', 'middle'); txt.setAttribute('dominant-baseline', 'middle');
        txt.setAttribute('fill', color); if (cls) txt.setAttribute('class', cls);
        txt.textContent = t;
        return txt;
    }
    function createCircle(x, y, r, cls = '', port = '') {
        let c = document.createElementNS(svgNS, 'circle');
        c.setAttribute('cx', x); c.setAttribute('cy', y); c.setAttribute('r', r);
        if (cls) c.setAttribute('class', cls); if (port) c.dataset.port = port;
        c.setAttribute('fill', 'white'); c.setAttribute('stroke', '#2c3e50'); c.setAttribute('stroke-width', '2');
        c.addEventListener('click', handlePointClick);
        return c;
    }
    function createGateElement(type, id, x, y, label = '') {
        let g = document.createElementNS(svgNS, 'g');
        g.setAttribute('transform', `translate(${x}, ${y})`);
        g.setAttribute('class', 'draggable'); g.dataset.id = id;
        g.appendChild(createText(25, -10, label, '12', '#2c3e50', 'labelText'));
        let height = (type === 'NOT') ? 30 : 50;
        g.appendChild(createRect(0, 0, 50, height, '#f5f7fa', '#2c3e50'));
        if (type === 'AND') {
            g.appendChild(createText(25, 25, '&', '22', '#2c3e50'));
            g.appendChild(createCircle(-5, 15, 7, 'input', 'in1'));
            g.appendChild(createCircle(-5, 35, 7, 'input', 'in2'));
            g.appendChild(createCircle(55, 25, 7, 'output', 'out'));
        } else if (type === 'OR') {
            g.appendChild(createText(25, 25, '‚â•1', '16', '#2c3e50'));
            g.appendChild(createCircle(-5, 15, 7, 'input', 'in1'));
            g.appendChild(createCircle(-5, 35, 7, 'input', 'in2'));
            g.appendChild(createCircle(55, 25, 7, 'output', 'out'));
        } else if (type === 'NOT') {
            g.appendChild(createText(25, 15, '1', '18', '#2c3e50'));
            g.appendChild(createCircle(-5, 15, 7, 'input', 'in'));
            g.appendChild(createCircle(55, 15, 7, 'output', 'out'));
            let bubble = document.createElementNS(svgNS, 'circle');
            bubble.setAttribute('cx', 49); bubble.setAttribute('cy', 15); bubble.setAttribute('r', 3);
            bubble.setAttribute('fill', 'white'); bubble.setAttribute('stroke', '#2c3e50');
            g.appendChild(bubble);
        }
        return g;
    }
    function createInputElement(id, x, y, value = 0, label = '') {
        let g = document.createElementNS(svgNS, 'g');
        g.setAttribute('transform', `translate(${x}, ${y})`);
        g.setAttribute('class', 'draggable'); g.dataset.id = id;
        g.appendChild(createText(20, -10, label, '12', '#2c3e50', 'labelText'));
        g.appendChild(createRect(0, 0, 40, 40, '#fff3e0', '#2c3e50'));
        let text = createText(20, 20, value.toString(), '22', value ? '#27ae60' : '#e74c3c', 'valueText');
        g.appendChild(text);
        g.appendChild(createCircle(45, 20, 7, 'output', 'out'));
        return g;
    }
    function createOutputElement(id, x, y, label = '') {
        let g = document.createElementNS(svgNS, 'g');
        g.setAttribute('transform', `translate(${x}, ${y})`);
        g.setAttribute('class', 'draggable'); g.dataset.id = id;
        g.appendChild(createText(20, -10, label, '12', '#2c3e50', 'labelText'));
        g.appendChild(createRect(0, 0, 40, 40, '#e8f4fd', '#2c3e50'));
        g.appendChild(createText(20, 20, '0', '22', '#e74c3c', 'valueText'));
        g.appendChild(createCircle(-5, 20, 7, 'input', 'in'));
        return g;
    }

    function addGate(type) {
        let id = nextId++;
        let x = Math.random() * 520 + 80;
        let y = Math.random() * 380 + 80;
        let g = createGateElement(type, id, x, y, '');
        svg.appendChild(g);
        components.push({ id, type, connectionsIn: {}, value: undefined, label: '' });
        makeDraggable(g);
        g.addEventListener('dblclick', editLabel);
        addDeleteListener(g);
        pushState();
    }
    function addInput() {
        let id = nextId++;
        let x = Math.random() * 520 + 80;
        let y = Math.random() * 380 + 80;
        let g = createInputElement(id, x, y, 0, '');
        svg.appendChild(g);
        components.push({ id, type: 'INPUT', value: 0, connectionsIn: {}, label: '' });
        makeDraggable(g);
        g.addEventListener('click', toggleInput);
        g.addEventListener('dblclick', editLabel);
        addDeleteListener(g);
        pushState();
    }
    function addOutput() {
        let id = nextId++;
        let x = Math.random() * 520 + 80;
        let y = Math.random() * 380 + 80;
        let g = createOutputElement(id, x, y, '');
        svg.appendChild(g);
        components.push({ id, type: 'OUTPUT', connectionsIn: {}, value: undefined, label: '' });
        makeDraggable(g);
        g.addEventListener('dblclick', editLabel);
        addDeleteListener(g);
        pushState();
    }

    function makeDraggable(elem) {
        let pos1, pos2, pos3, pos4, startTrans, dragged = false;
        elem.addEventListener('mousedown', dragMouseDown);
        elem.addEventListener('touchstart', dragTouchStart, { passive: false });

        function dragMouseDown(e) {
            if (e.target.tagName === 'circle') return;
            e.preventDefault();
            startTrans = getTranslateFromElement(elem);
            pos3 = e.clientX; pos4 = e.clientY;
            document.addEventListener('mouseup', closeDrag);
            document.addEventListener('mousemove', elementDrag);
        }
        function dragTouchStart(e) {
            if (e.touches.length !== 1 || e.target.tagName === 'circle') return;
            e.preventDefault();
            startTrans = getTranslateFromElement(elem);
            pos3 = e.touches[0].clientX; pos4 = e.touches[0].clientY;
            document.addEventListener('touchend', closeDrag);
            document.addEventListener('touchmove', elementTouchMove, { passive: false });
        }
        function elementDrag(e) {
            e.preventDefault();
            pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY;
            pos3 = e.clientX; pos4 = e.clientY;
            let trans = getTranslateFromElement(elem);
            let x = trans.x - pos1; let y = trans.y - pos2;
            elem.setAttribute('transform', `translate(${x}, ${y})`);
            updateWiresForComp(elem.dataset.id);
            dragged = true;
        }
        function elementTouchMove(e) {
            if (e.touches.length !== 1) return;
            e.preventDefault();
            pos1 = pos3 - e.touches[0].clientX; pos2 = pos4 - e.touches[0].clientY;
            pos3 = e.touches[0].clientX; pos4 = e.touches[0].clientY;
            let trans = getTranslateFromElement(elem);
            let x = trans.x - pos1; let y = trans.y - pos2;
            elem.setAttribute('transform', `translate(${x}, ${y})`);
            updateWiresForComp(elem.dataset.id);
            dragged = true;
        }
        function closeDrag() {
            if (dragged) pushState();
            dragged = false;
            document.removeEventListener('mouseup', closeDrag);
            document.removeEventListener('mousemove', elementDrag);
            document.removeEventListener('touchend', closeDrag);
            document.removeEventListener('touchmove', elementTouchMove);
        }
    }

    function captureState() {
        const comps = components.map(c => {
            const g = svg.querySelector(`g[data-id="${c.id}"]`);
            const pos = getTranslateFromElement(g);
            return { id: c.id, type: c.type, x: pos.x, y: pos.y, value: c.value, label: c.label || '' };
        });
        const conns = connections.map(conn => ({
            from: { id: conn.from.id, port: conn.from.port },
            to: { id: conn.to.id, port: conn.to.port }
        }));
        return { components: comps, connections: conns, specFValues: [...specFValues] };
    }
    function pushState() {
        const state = captureState();
        historyStack = historyStack.slice(0, historyIndex + 1);
        historyStack.push(state);
        if (historyStack.length > MAX_HISTORY) historyStack.shift();
        historyIndex = historyStack.length - 1;
    }
    function restoreState(state) {
        svg.innerHTML = '';
        components = []; connections = [];
        state.components.forEach(comp => {
            let g;
            if (comp.type === 'INPUT') g = createInputElement(comp.id, comp.x, comp.y, comp.value || 0, comp.label);
            else if (comp.type === 'OUTPUT') g = createOutputElement(comp.id, comp.x, comp.y, comp.label);
            else g = createGateElement(comp.type, comp.id, comp.x, comp.y, comp.label);
            svg.appendChild(g);
            components.push({ id: comp.id, type: comp.type, connectionsIn: {}, value: comp.value, label: comp.label });
            makeDraggable(g);
            if (comp.type === 'INPUT') g.addEventListener('click', toggleInput);
            g.addEventListener('dblclick', editLabel);
            addDeleteListener(g);
        });
        state.connections.forEach(conn => {
            const startPos = getPointPos(conn.from.id, conn.from.port);
            const endPos = getPointPos(conn.to.id, conn.to.port);
            const line = document.createElementNS(svgNS, 'line');
            line.setAttribute('stroke', '#2c3e50'); line.setAttribute('stroke-width', '2.5');
            line.setAttribute('x1', startPos.x); line.setAttribute('y1', startPos.y);
            line.setAttribute('x2', endPos.x); line.setAttribute('y2', endPos.y);
            svg.insertBefore(line, svg.firstChild);
            connections.push({ from: conn.from, to: conn.to, line });
            const target = components.find(c => c.id == conn.to.id);
            if (!target.connectionsIn) target.connectionsIn = {};
            target.connectionsIn[conn.to.port] = { fromId: conn.from.id, fromPort: conn.from.port };
        });
        nextId = components.reduce((max, c) => Math.max(max, c.id), -1) + 1;
        if (state.specFValues) {
            specFValues = [...state.specFValues];
            renderSpecTable();
            renderKMap();
            updateSpecExpressions();
        }
        if (simulating) propagate();
    }
    function undo() {
        if (historyIndex > 0) { historyIndex--; restoreState(historyStack[historyIndex]); }
        else { statusSpan.textContent = '‚ö° nothing to undo'; setTimeout(updateStatus, 1200); }
    }
    function redo() {
        if (historyIndex < historyStack.length - 1) { historyIndex++; restoreState(historyStack[historyIndex]); }
        else { statusSpan.textContent = '‚ö° nothing to redo'; setTimeout(updateStatus, 1200); }
    }

    function saveCircuit() {
        const state = captureState();
        const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'minisim-circuit.json'; a.click();
        URL.revokeObjectURL(url);
        statusSpan.textContent = '‚úÖ saved';
        setTimeout(updateStatus, 1500);
    }
    function loadCircuit() {
        const input = document.createElement('input');
        input.type = 'file'; input.accept = '.json';
        input.onchange = e => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = ev => {
                try {
                    const state = JSON.parse(ev.target.result);
                    restoreState(state);
                    pushState();
                    statusSpan.textContent = '‚úÖ loaded';
                    setTimeout(updateStatus, 1500);
                } catch(err) { alert('Invalid file'); }
            };
            reader.readAsText(file);
        };
        input.click();
    }

    function randomSpec() {
        for (let i = 0; i < specRows; i++) {
            const r = Math.random();
            specFValues[i] = r < 0.4 ? 0 : r < 0.8 ? 1 : 'X';
        }
    }
    function renderSpecTable() {
        let html = '';
        for (let i = 0; i < specRows; i++) {
            const a = (i >> 3) & 1, b = (i >> 2) & 1, c = (i >> 1) & 1, d = i & 1;
            html += `<tr>
                <td class="fixed-col">${a}</td>
                <td class="fixed-col">${b}</td>
                <td class="fixed-col">${c}</td>
                <td class="fixed-col">${d}</td>
<td class="f-cell" data-index="${i}" data-val="${specFValues[i]}">${specFValues[i]}</td>

            </tr>`;
        }
        specTbody.innerHTML = html;
        document.querySelectorAll('.f-cell').forEach(cell => {
            cell.addEventListener('click', (e) => {
                e.preventDefault();
                const idx = parseInt(cell.dataset.index);
                const cur = specFValues[idx];
                specFValues[idx] = cur === 0 ? 1 : cur === 1 ? 'X' : 0;
                renderSpecTable();
                renderKMap();
                updateSpecExpressions();
                pushState();
            });
        });
    }

    function renderKMap() {
        let html = '';
        for (let r = 0; r < 4; r++) {
            html += `<tr><th>${kmapGray[r].toString(2).padStart(2,'0')}</th>`;
            for (let c = 0; c < 4; c++) {
                const minterm = (kmapGray[r] << 2) | kmapGray[c];
                const val = specFValues[minterm];
                html += `<td class="kmap-cell" data-minterm="${minterm}" data-val="${val}">${val}</td>`;

            }
            html += '</tr>';
        }
        kmapBody.innerHTML = html;
        document.querySelectorAll('.kmap-cell').forEach(cell => {
            cell.addEventListener('click', (e) => {
                e.preventDefault();
                const m = parseInt(cell.dataset.minterm);
                const cur = specFValues[m];
                specFValues[m] = cur === 0 ? 1 : cur === 1 ? 'X' : 0;
                renderSpecTable();
                renderKMap();
                updateSpecExpressions();
                pushState();
            });
        });
    }

    function covers(pi, minterm) {
        for (let i = 0; i < 4; i++) if (pi[i] !== '-' && pi[i] !== minterm[i]) return false;
        return true;
    }
    function simplifyLogic(targetTerms, allowedTerms) {
        if (targetTerms.length === 0) return [];
        if (allowedTerms.length === 16) return ['----'];
        let combined = new Set(allowedTerms.map(m => m.toString(2).padStart(4, '0')));
        let pis = new Set();
        let hasMerged = true;
        while (hasMerged) {
            hasMerged = false;
            let next = new Set();
            let used = new Set();
            let arr = Array.from(combined);
            for (let i = 0; i < arr.length; i++) {
                for (let j = i + 1; j < arr.length; j++) {
                    let diff = 0, idx = -1;
                    for (let k = 0; k < 4; k++) if (arr[i][k] !== arr[j][k]) { diff++; idx = k; }
                    if (diff === 1) {
                        next.add(arr[i].substring(0, idx) + '-' + arr[i].substring(idx + 1));
                        used.add(arr[i]); used.add(arr[j]);
                        hasMerged = true;
                    }
                }
            }
            for (let t of arr) if (!used.has(t)) pis.add(t);
            combined = next;
        }
        let piArray = Array.from(pis);
        let remaining = new Set(targetTerms.map(m => m.toString(2).padStart(4, '0')));
        let selected = [];
        for (let m of remaining) {
            let candidates = piArray.filter(pi => covers(pi, m));
            if (candidates.length === 1) {
                let epi = candidates[0];
                if (!selected.includes(epi)) {
                    selected.push(epi);
                    for (let rm of Array.from(remaining)) if (covers(epi, rm)) remaining.delete(rm);
                }
            }
        }
        while (remaining.size > 0) {
            let best = null, max = -1;
            for (let pi of piArray) {
                if (selected.includes(pi)) continue;
                let count = 0;
                for (let rm of remaining) if (covers(pi, rm)) count++;
                if (count > max) { max = count; best = pi; }
            }
            if (!best) break;
            selected.push(best);
            for (let rm of Array.from(remaining)) if (covers(best, rm)) remaining.delete(rm);
        }
        return selected;
    }

    function updateSpecExpressions() {
        let ones = [], zeros = [], dcares = [];
        for (let i = 0; i < specRows; i++) {
            if (specFValues[i] === 1) ones.push(i);
            else if (specFValues[i] === 0) zeros.push(i);
            else dcares.push(i);
        }
        let sopTerms = ones.map(m => (m&8?'a':'a\'') + (m&4?'b':'b\'') + (m&2?'c':'c\'') + (m&1?'d':'d\''));
        let sopD = dcares.map(m => `<span class="d-care">${(m&8?'a':'a\'') + (m&4?'b':'b\'') + (m&2?'c':'c\'') + (m&1?'d':'d\'')}</span>`);
        sopSpan.innerHTML = (sopTerms.length || sopD.length) ? sopTerms.concat(sopD).join(' + ') : '0';

        let posTerms = zeros.map(m => `(${(m&8?'a\'':'a')} + ${(m&4?'b\'':'b')} + ${(m&2?'c\'':'c')} + ${(m&1?'d\'':'d')})`);
        let posD = dcares.map(m => `<span class="d-care">(${(m&8?'a\'':'a')} + ${(m&4?'b\'':'b')} + ${(m&2?'c\'':'c')} + ${(m&1?'d\'':'d')})</span>`);
        posSpan.innerHTML = (posTerms.length || posD.length) ? posTerms.concat(posD).join(' ¬∑ ') : '1';

        let simpsopPIs = simplifyLogic(ones, ones.concat(dcares));
        window.currentSimpSOP = simpsopPIs;
        if (simpsopPIs.length === 0) simpsopSpan.innerText = '0';
        else if (simpsopPIs.includes('----')) simpsopSpan.innerText = '1';
        else {
            simpsopSpan.innerText = simpsopPIs.map(pi => {
                let term = '';
                for (let i = 0; i < 4; i++) {
                    if (pi[i] === '1') term += specVarNames[i];
                    else if (pi[i] === '0') term += specVarNames[i] + "'";
                }
                return term || '1';
            }).join(' + ');
        }

        let simpposPIs = simplifyLogic(zeros, zeros.concat(dcares));
        if (simpposPIs.length === 0) simpposSpan.innerText = '1';
        else if (simpposPIs.includes('----')) simpposSpan.innerText = '0';
        else {
            simpposSpan.innerText = simpposPIs.map(pi => {
                let vars = [];
                for (let i = 0; i < 4; i++) {
                    if (pi[i] === '0') vars.push(specVarNames[i]);
                    else if (pi[i] === '1') vars.push(specVarNames[i] + "'");
                }
                return '(' + vars.join(' + ') + ')';
            }).join(' ¬∑ ');
        }
    }


// ===================================================================




 
// Build a two-level SOP circuit with correct positions and connections
// - Inputs a,b,c,d
// - NOTs only if needed by any term (literal '0')
// - For each term: chain of 2-input ANDs (or direct if 1 literal)
// - OR chain to combine all products to OUTPUT
// - Handles edge cases: f=0 (no terms) and f=1 (terms includes '----')
// ===================================================================
function buildCircuitFromTerms(terms) {
    // Reset canvas/state
    svg.innerHTML = '';
    components = [];
    connections = [];
    nextId = 0;

    // Small helpers
    function connect(fromId, fromPort, toId, toPort) {
        const start = getPointPos(fromId, fromPort);
        const end = getPointPos(toId, toPort);
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', start.x); line.setAttribute('y1', start.y);
        line.setAttribute('x2', end.x); line.setAttribute('y2', end.y);
        line.setAttribute('stroke', '#2c3e50'); line.setAttribute('stroke-width', '2.8');
        svg.insertBefore(line, svg.firstChild);
        connections.push({ from: { id: fromId, port: fromPort }, to: { id: toId, port: toPort }, line });
        const target = components.find(c => c.id === toId);
        if (target) {
            if (!target.connectionsIn) target.connectionsIn = {};
            target.connectionsIn[toPort] = { fromId, fromPort };
        }
    }
    function addGateAt(type, x, y, label = '') {
        const id = nextId++;
        const g = createGateElement(type, id, x, y, label);
        svg.appendChild(g);
        components.push({ id, type, connectionsIn: {}, value: undefined, label });
        makeDraggable(g);
        g.addEventListener('dblclick', editLabel);
        addDeleteListener(g);
        return id;
    }
    function addInputAt(x, y, value, label) {
        const id = nextId++;
        const g = createInputElement(id, x, y, value, label);
        svg.appendChild(g);
        components.push({ id, type: 'INPUT', value, connectionsIn: {}, label });
        makeDraggable(g);
        g.addEventListener('click', toggleInput);
        g.addEventListener('dblclick', editLabel);
        addDeleteListener(g);
        return id;
    }
    function addOutputAt(x, y, label) {
        const id = nextId++;
        const g = createOutputElement(id, x, y, label);
        svg.appendChild(g);
        components.push({ id, type: 'OUTPUT', connectionsIn: {}, value: undefined, label });
        makeDraggable(g);
        g.addEventListener('dblclick', editLabel);
        addDeleteListener(g);
        return id;
    }

    // Normalize and trivial cases
    if (!Array.isArray(terms)) terms = [];
    // Remove duplicates / ensure valid 4-chars of 0/1/- 
    terms = Array.from(new Set(terms.filter(t => typeof t === 'string' && t.length === 4 && /^[01-]{4}$/.test(t))));
    if (terms.length === 0) {
        // f = 0 ‚Üí draw constant 0 ‚Üí Output
        const const0 = addInputAt(100, 220, 0, '0');
        const outId = addOutputAt(650, 220, 'F');
        connect(const0, 'out', outId, 'in');
        pushState();
        if (simulating) propagate();
        return;
    }
    if (terms.includes('----')) {
        // f = 1 ‚Üí draw constant 1 ‚Üí Output
        const const1 = addInputAt(100, 220, 1, '1');
        const outId = addOutputAt(650, 220, 'F');
        connect(const1, 'out', outId, 'in');
        pushState();
        if (simulating) propagate();
        return;
    }

    // Layout columns
    const COL = { IN: 70, NOT: 180, AND_START: 300, AND_STEP: 90, OR: 520, OUT: 680 };
    const ROW = { TOP: 90, STEP: 90 };

    // 1) Inputs a,b,c,d
    const inputY = [80, 165, 250, 335];
    const inputIds = [];
    for (let i = 0; i < 4; i++) {
        inputIds.push(addInputAt(COL.IN, inputY[i], 0, specVarNames[i]));
    }

    // 2) NOT gates only if needed by any term having '0' on that variable
    const needNot = [0, 1, 2, 3].map(i => terms.some(t => t[i] === '0'));
    const notIds = [null, null, null, null];
    let nextNotY = 95;
    for (let i = 0; i < 4; i++) {
        if (needNot[i]) {
            notIds[i] = addGateAt('NOT', COL.NOT, nextNotY, specVarNames[i] + "'");
            // Wire input ‚Üí NOT
            connect(inputIds[i], 'out', notIds[i], 'in');
            nextNotY += 78;
        }
    }

    // 3) Build each product term with a 2-input AND chain (if needed)
    //    Also compute a readable label for the final AND of each term.
    function termLabelOf(t) {
        let s = '';
        for (let i = 0; i < 4; i++) {
            if (t[i] === '1') s += specVarNames[i];
            else if (t[i] === '0') s += specVarNames[i] + "'";
        }
        return s || '1';
    }

    const products = []; // [{id, port:'out', y}]
    terms.forEach((t, k) => {
        const y = ROW.TOP + k * ROW.STEP;
        // Gather literal sources (id of INPUT or NOT)
        const literals = [];
        for (let i = 0; i < 4; i++) {
            if (t[i] === '1') literals.push({ id: inputIds[i], port: 'out' });
            else if (t[i] === '0') literals.push({ id: notIds[i], port: 'out' });
        }
        if (literals.length === 0) {
            // Shouldn't happen (we would have early-returned on '----')
            return;
        }
        if (literals.length === 1) {
            // Single literal: direct feed
            products.push({ id: literals[0].id, port: literals[0].port, y });
        } else {
            // Build a chain of ANDs at AND_START, AND_START+STEP, ...
            let current = literals[0];
            for (let j = 1; j < literals.length; j++) {
                const isLast = (j === literals.length - 1);
                const label = isLast ? termLabelOf(t) : '';
                const andId = addGateAt('AND', COL.AND_START + (j - 1) * COL.AND_STEP, y, label);
                connect(current.id, current.port, andId, 'in1');
                connect(literals[j].id, literals[j].port, andId, 'in2');
                current = { id: andId, port: 'out' };
            }
            products.push({ id: current.id, port: current.port, y });
        }
    });

    // 4) Combine products with an OR chain
    let finalSource = null;
    if (products.length === 1) {
        finalSource = { id: products[0].id, port: products[0].port };
    } else {
        let current = { id: products[0].id, port: products[0].port };
        for (let i = 1; i < products.length; i++) {
            // Stack OR gates vertically
            const orY = ROW.TOP + (i - 1) * ROW.STEP;
            const orId = addGateAt('OR', COL.OR, orY, '');
            connect(current.id, current.port, orId, 'in1');
            connect(products[i].id, products[i].port, orId, 'in2');
            current = { id: orId, port: 'out' };
        }
        finalSource = current;
    }

    // 5) Output
    const avgY = (() => {
        if (products.length === 1) return products[0].y;
        const ys = products.map(p => p.y);
        return Math.round((Math.min(...ys) + Math.max(...ys)) / 2);
    })();
    const outId = addOutputAt(COL.OUT, Math.min(360, Math.max(100, avgY)), 'F');
    connect(finalSource.id, finalSource.port, outId, 'in');

    // Finish
    pushState();
    if (simulating) propagate();
}



    function updateStatus() {
        if (wiring) statusSpan.innerHTML = startPoint ? 'üìç select input port' : 'üîå wiring mode';
        else if (simulating) statusSpan.innerHTML = '‚ö° simulation ON';
        else statusSpan.innerHTML = '‚ö° ready';
    }

    window.addGate = addGate;
    window.addInput = addInput;
    window.addOutput = addOutput;
    window.toggleWireMode = toggleWireMode;
    window.toggleSimulate = toggleSimulate;
    window.saveCircuit = saveCircuit;
    window.loadCircuit = loadCircuit;
    window.undo = undo;
    window.redo = redo;

    renderSpecTable();
    renderKMap();
    updateSpecExpressions();

    document.getElementById('randomSpecBtn').addEventListener('click', () => {
        randomSpec();
        renderSpecTable();
        renderKMap();
        updateSpecExpressions();
        pushState();
    });
    document.getElementById('resetSpecBtn').addEventListener('click', () => {
        specFValues.fill(0);
        renderSpecTable();
        renderKMap();
        updateSpecExpressions();
        pushState();
    });
    document.getElementById('buildCircuitBtn').addEventListener('click', () => {
        buildCircuitFromTerms(window.currentSimpSOP || []);
    });

    const helpModal = document.getElementById('helpModal');
    const helpOverlay = document.getElementById('helpOverlay');
    window.openHelpModal = function() { helpModal.style.display = 'block'; helpOverlay.style.display = 'block'; };
    window.closeHelpModal = function() { helpModal.style.display = 'none'; helpOverlay.style.display = 'none'; };
    document.getElementById('helpButton').addEventListener('click', openHelpModal);

    pushState();
    updateStatus();
})();
</script>
</body>
</html>

















