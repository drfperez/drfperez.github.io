<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8">
  <title>Mini Transat ‚Äì Vent, Corrent i Animaci√≥</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    #map { height: 100vh; width: 75%; float: left; }
    #sidebar {
      float: right;
      width: 25%;
      height: 100vh;
      overflow-y: auto;
      padding: 10px;
      box-sizing: border-box;
      background: #f0f0f0;
    }
    #controls { margin-bottom: 20px; }
    .wind-entry {
      background: #fff;
      margin-bottom: 10px;
      padding: 10px;
      border-radius: 6px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    }
    #eta {
      margin-top: 20px;
      padding: 10px;
      background: #e0ffe0;
      border-radius: 6px;
    }
    label, input, select, button { display: block; margin-top: 10px; }
    button {
      padding: 6px 10px;
      border: none;
      background: #007bff;
      color: white;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover { background: #0056b3; }
    .info-panel { background: #f9f9f9; padding: 15px; border-radius: 8px; border: 1px solid #ccc; margin-top: 15px; }
    .info-panel pre { background: #eee; padding: 5px; border-radius: 4px; overflow-x: auto; }
  </style>
</head>
<body>

  <div id="map"></div>
  <div id="sidebar">
    <div id="controls">
      <label for="stage">Etapa:</label>
      <select id="stage">
        <option value="all">Totes</option>
        <option value="1">Etapa 1: Fran√ßa ‚Üí Can√†ries</option>
        <option value="2">Etapa 2: Can√†ries ‚Üí Guadalupe</option>
      </select>

      <label for="manualSpeed">Simular velocitat mitjana (km/h):</label>
      <input type="range" id="manualSpeed" min="2" max="20" step="0.5" value="0">
      <span id="speedValue">Autom√†tica</span>

      <label for="manualCurrent">Corrent mar√≠ (km/h):</label>
      <input type="range" id="manualCurrent" min="0" max="5" step="0.1" value="0">
      <span id="currentValue">0 km/h</span>

      <label for="currentDirection">Direcci√≥ del corrent:</label>
      <select id="currentDirection">
        <option value="+">Afavoreix (‚Üí)</option>
        <option value="-">Frena (‚Üê)</option>
      </select>

      <label for="animMultiplier">Multiplicador d'animaci√≥:</label>
      <input type="range" id="animMultiplier" min="0.1" max="10" step="0.1" value="1">
      <span id="multiplierValue">1√ó</span>

      <button id="startAnimation">Iniciar animaci√≥</button>
      <button onclick="toggleInfo()">üìò Explicaci√≥ dels c√†lculs</button>
    </div>

    <h3>Dades del vent</h3>
    <div id="wind-data"></div>
    <div id="eta"></div>

    <div id="infoPanel" class="info-panel" style="display:none">
      <h2>üß≠ Explicaci√≥ dels c√†lculs de navegaci√≥</h2>

      <h3>1. C√†lcul de la dist√†ncia (F√≥rmula de Haversine)</h3>
      <p>Per saber quants km hi ha entre dues etapes, usem la f√≥rmula de <strong>Haversine</strong>, que t√© en compte la curvatura de la Terra:</p>
      <pre>
d = 2r * arcsin( ‚àö(sin¬≤((ŒîœÜ)/2) + cos œÜ1 ‚ãÖ cos œÜ2 ‚ãÖ sin¬≤((ŒîŒª)/2)) )
      </pre>
      <p>on:
        <ul>
          <li><strong>œÜ</strong> √©s la latitud</li>
          <li><strong>Œª</strong> √©s la longitud</li>
          <li><strong>r</strong> √©s el radi de la Terra (6371 km)</li>
        </ul>
      </p>

      <h3>2. Velocitat efectiva</h3>
      <p>La velocitat de l'embarcaci√≥ s'ajusta amb el vent i el corrent. Si el vent o corrent va en contra, frena; si ajuda, augmenta:</p>
      <pre>
velocitat_ajustada = velocitat_base ¬± efecte_corrent ¬± efecte_vent
      </pre>

      <h3>3. Estimaci√≥ del temps</h3>
      <p>Un cop sabem la dist√†ncia entre punts i la velocitat ajustada, calculem el temps estimat:</p>
      <pre>
temps = dist√†ncia / velocitat
      </pre>
      <p>El temps final s‚Äôexpressa en dies i hores.</p>

      <h3>4. Representaci√≥ gr√†fica (animaci√≥)</h3>
      <p>Per simular la navegaci√≥, el vaixell es mou sobre un mapa i canvia de posici√≥ en funci√≥ de la velocitat real. Aquesta animaci√≥ permet veure com el vent i el corrent poden influir en el ritme de la regata.</p>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    function toggleInfo() {
      const panel = document.getElementById("infoPanel");
      panel.style.display = panel.style.display === "none" ? "block" : "none";
    }

    // Coordenades dels ports
    const lesSables   = [46.4961, -1.7847];
    const laPalma     = [28.6836, -17.7649];
    const guadeloupe  = [16.2572, -61.5676];

    // Inicialitzaci√≥ del mapa
    const map = L.map('map').setView([30, -30], 3);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Polil√≠nies de cada etapa
    const etapa1     = L.polyline([lesSables, laPalma], { color: 'blue' });
    const etapa2     = L.polyline([laPalma, guadeloupe], { color: 'green' });
    const etapaTotal = L.polyline([lesSables, laPalma, guadeloupe], { color: 'red' });

    let windMarkers = [];
    let boatMarker = null;
    let animationTimeouts = [];

    // C√†lcul de dist√†ncia Haversine
    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371; // radi de la Terra en km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2)**2 +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    // Obtenim llista de coordenades √∫niques segons etapa
    function getUniqueCoords(stage) {
      let coords;
      if (stage === '1')      coords = [lesSables, laPalma];
      else if (stage === '2') coords = [laPalma, guadeloupe];
      else                    coords = [lesSables, laPalma, guadeloupe];

      const seen = new Set();
      const uniqueCoords = [];
      coords.forEach(([lat, lon]) => {
        const key = `${lat.toFixed(4)},${lon.toFixed(4)}`;
        if (!seen.has(key)) {
          seen.add(key);
          uniqueCoords.push([lat, lon]);
        }
      });
      return uniqueCoords;
    }

    // Actualitza dades de vent, ETA i prepara animaci√≥
    async function updateWindAndETA(stage) {
      // Neteja marcadors anteriors
      windMarkers.forEach(m => map.removeLayer(m));
      windMarkers = [];
      if (boatMarker) {
        map.removeLayer(boatMarker);
        boatMarker = null;
      }
      animationTimeouts.forEach(t => clearTimeout(t));
      animationTimeouts = [];

      // Coordenades separades per a aquesta etapa
      const uniqueCoords = getUniqueCoords(stage);

      // Mostrem nom√©s la polil√≠nia corresponent
      etapa1.remove(); etapa2.remove(); etapaTotal.remove();
      if (stage === '1') etapa1.addTo(map);
      else if (stage === '2') etapa2.addTo(map);
      else etapaTotal.addTo(map);

      // Panell lateral: esborrem contingut
      const windDataContainer = document.getElementById("wind-data");
      const etaContainer = document.getElementById("eta");
      windDataContainer.innerHTML = "";
      etaContainer.innerHTML = "Calculant estimaci√≥ de durada...";

      // C√†lcul de dist√†ncia total (km)
      let totalDistance = 0;
      for (let i = 0; i < uniqueCoords.length - 1; i++) {
        totalDistance += haversineDistance(
          uniqueCoords[i][0], uniqueCoords[i][1],
          uniqueCoords[i+1][0], uniqueCoords[i+1][1]
        );
      }

      // Par√†metres de simulaci√≥
      const manualSpeed      = parseFloat(document.getElementById("manualSpeed").value);
      const manualCurrent    = parseFloat(document.getElementById("manualCurrent").value);
      const currentDirection = document.getElementById("currentDirection").value;
      document.getElementById("currentValue").textContent =
        `${manualCurrent} km/h (${currentDirection === '+' ? 'Afavoreix' : 'Frena'})`;
      if (manualSpeed > 0) {
        document.getElementById("speedValue").textContent =
          `${manualSpeed} km/h (Simulaci√≥)`;
      } else {
        document.getElementById("speedValue").textContent =
          "Autom√†tica (vent real)";
      }

      // Recuperem dades de vent per a cada punt
      let totalWindSpeed = 0;
      let pointsUsed = 0;

      const windPromises = uniqueCoords.map(async ([lat, lon]) => {
        try {
          const now = new Date();
          const currentHour = now.getHours();
          const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=wind_speed_10m,wind_direction_10m&timezone=auto`;
          const res = await fetch(url);
          const data = await res.json();
          const windSpeed = data.hourly.wind_speed_10m[currentHour];
          const windDir = data.hourly.wind_direction_10m[currentHour];
          totalWindSpeed += windSpeed;
          pointsUsed++;
          // Dibuixem marcador de vent amb fletxa
          const icon = L.divIcon({
            html: `<div style="transform: rotate(${windDir}deg); font-size: 20px;">‚Üë</div>`,
            className: ''
          });
          const marker = L.marker([lat, lon], { icon })
            .bindPopup(`üå¨Ô∏è Vent: ${windSpeed} km/h<br>üß≠ Direcci√≥: ${windDir}¬∞`)
            .addTo(map);
          windMarkers.push(marker);

          // Tamb√© afegim al panell lateral
          windDataContainer.innerHTML += `
            <div class="wind-entry">
              <strong>Lat: ${lat.toFixed(2)}, Lon: ${lon.toFixed(2)}</strong><br>
              üå¨Ô∏è Velocitat: ${windSpeed} km/h<br>
              üß≠ Direcci√≥: ${windDir}¬∞
            </div>`;
        } catch (e) {
          console.error("Error carregant dades del vent:", e);
        }
      });

      // Esperem totes les crides
      await Promise.all(windPromises);

      // C√†lcul de velocitat efectiva (km/h)
      const avgWindSpeed = totalWindSpeed / pointsUsed;
      let effectiveSpeed = (manualSpeed > 0 ? manualSpeed : avgWindSpeed);
      effectiveSpeed += (currentDirection === '+' ? 1 : -1) * manualCurrent;

      // C√†lcul d'ETA (hores)
      const estimatedHours = totalDistance / effectiveSpeed;
      const days = Math.floor(estimatedHours / 24);
      const hours = Math.round(estimatedHours % 24);
      etaContainer.innerHTML = `
        <strong>Estimaci√≥ del temps de viatge:</strong><br>
        Dist√†ncia total: ${totalDistance.toFixed(0)} km<br>
        Velocitat ajustada: ${effectiveSpeed.toFixed(1)} km/h<br>
        Durada estimada: ${days} dies i ${hours} hores.
      `;

      // Definim animaci√≥ al bot√≥
      document.getElementById("startAnimation").onclick = () => {
        animateBoat(uniqueCoords, effectiveSpeed);
      };
    }

    // Funci√≥ per animar el vaixell al llarg del recorregut
    function animateBoat(pathCoords, effectiveSpeed) {
      // Neteja animacions anteriors
      animationTimeouts.forEach(t => clearTimeout(t));
      animationTimeouts = [];
      if (boatMarker) {
        map.removeLayer(boatMarker);
        boatMarker = null;
      }

      // Icona de vaixell (emoji ‚õµ)
      const boatIcon = L.divIcon({
        html: '‚õµ',
        className: '',
        iconSize: [24, 24],
        iconAnchor: [12, 12]
      });

      // Situem marcador al punt inicial
      const [startLat, startLon] = pathCoords[0];
      boatMarker = L.marker([startLat, startLon], { icon: boatIcon }).addTo(map);

      // Multiplicador d'animaci√≥
      const animMultiplier = parseFloat(document.getElementById("animMultiplier").value) || 1;
      // Factor base: 500 ms per hora real
      const baseTimeScale = 500; // ms per hora
      // Aplicar multiplicador (m√©s alt ‚Üí animaci√≥ m√©s r√†pida)
      const timeScale = baseTimeScale / animMultiplier;

      let cumulativeTime = 0;
      // Per cada segment, calculem temps i creem un timeout
      for (let i = 0; i < pathCoords.length - 1; i++) {
        const [lat1, lon1] = pathCoords[i];
        const [lat2, lon2] = pathCoords[i + 1];
        const segmentDistance = haversineDistance(lat1, lon1, lat2, lon2);
        const segmentTimeHours = segmentDistance / effectiveSpeed;
        const segmentTimeMs = segmentTimeHours * timeScale;
        cumulativeTime += segmentTimeMs;

        // Programem el salt del marcador
        const timeout = setTimeout(((lat, lon) => () => {
          boatMarker.setLatLng([lat, lon]);
        })(lat2, lon2), cumulativeTime);
        animationTimeouts.push(timeout);
      }
    }

    // Quan es canvii el valor del multiplicador, actualitzem la visualitzaci√≥ del n√∫mero
    document.getElementById("animMultiplier").addEventListener("input", function() {
      document.getElementById("multiplierValue").textContent = this.value + "√ó";
    });

    // Event listeners per controls
    document.getElementById("stage").addEventListener("change", e => {
      updateWindAndETA(e.target.value);
    });
    document.getElementById("manualSpeed").addEventListener("input", () => {
      updateWindAndETA(document.getElementById("stage").value);
    });
    document.getElementById("manualCurrent").addEventListener("input", () => {
      updateWindAndETA(document.getElementById("stage").value);
    });
    document.getElementById("currentDirection").addEventListener("change", () => {
      updateWindAndETA(document.getElementById("stage").value);
    });

    // Iniciem amb la vista per defecte (totes les etapes)
    updateWindAndETA("all");
  </script>
</body>
</html>
